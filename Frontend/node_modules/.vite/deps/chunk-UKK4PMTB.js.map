{
  "version": 3,
  "sources": ["../../ol/expr/expression.js", "../../ol/expr/cpu.js", "../../ol/render/canvas/style.js", "../../ol/layer/BaseVector.js"],
  "sourcesContent": ["/**\r\n * @module ol/expr/expression\r\n */\r\nimport {ascending} from '../array.js';\r\nimport {isStringColor} from '../color.js';\r\n\r\n/**\r\n * @fileoverview This module includes types and functions for parsing array encoded expressions.\r\n * The result of parsing an encoded expression is one of the specific expression classes.\r\n * During parsing, information is added to the parsing context about the data accessed by the\r\n * expression.\r\n */\r\n\r\n/**\r\n * Base type used for literal style parameters; can be a number literal or the output of an operator,\r\n * which in turns takes {@link import(\"./expression.js\").ExpressionValue} arguments.\r\n *\r\n * See below for details on the available operators (with notes for those that are WebGL or Canvas only).\r\n *\r\n * * Reading operators:\r\n *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band\r\n *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values\r\n *     are in the 0..1 range. {@link import(\"../source/TileImage.js\").default} sources have 4 bands: red,\r\n *     green, blue and alpha. {@link import(\"../source/DataTile.js\").default} sources can have any number\r\n *     of bands, depending on the underlying data source and\r\n *     {@link import(\"../source/GeoTIFF.js\").Options configuration}. `xOffset` and `yOffset` are optional\r\n *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels (WebGL only).\r\n *   * `['get', 'attributeName', typeHint]` fetches a feature property value, similar to `feature.get('attributeName')`\r\n *     A type hint can optionally be specified, in case the resulting expression contains a type ambiguity which\r\n *     will make it invalid. Type hints can be one of: 'string', 'color', 'number', 'boolean', 'number[]'\r\n *   * `['geometry-type']` returns a feature's geometry type as string, either: 'LineString', 'Point' or 'Polygon'\r\n *     `Multi*` values are returned as their singular equivalent\r\n *     `Circle` geometries are returned as 'Polygon'\r\n *     `GeometryCollection` geometries are returned as the type of the first geometry found in the collection (WebGL only).\r\n *   * `['resolution']` returns the current resolution\r\n *   * `['time']` The time in seconds since the creation of the layer (WebGL only).\r\n *   * `['var', 'varName']` fetches a value from the style variables; will throw an error if that variable is undefined\r\n *   * `['zoom']` The current zoom level (WebGL only).\r\n *\r\n * * Math operators:\r\n *   * `['*', value1, value2, ...]` multiplies the values (either numbers or colors)\r\n *   * `['/', value1, value2]` divides `value1` by `value2`\r\n *   * `['+', value1, value2, ...]` adds the values\r\n *   * `['-', value1, value2]` subtracts `value2` from `value1`\r\n *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`\r\n *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)\r\n *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power\r\n *   * `['abs', value1]` returns the absolute value of `value1`\r\n *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`\r\n *   * `['round', value1]` returns the nearest integer to `value1`\r\n *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`\r\n *   * `['sin', value1]` returns the sine of `value1`\r\n *   * `['cos', value1]` returns the cosine of `value1`\r\n *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`\r\n *   * `['sqrt', value1]` returns the square root of `value1`\r\n *\r\n * * Transform operators:\r\n *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding\r\n *     condition evaluates to `true`. If no match is found, returns the `fallback` value.\r\n *     All conditions should be `boolean`, output and fallback can be any kind.\r\n *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all\r\n *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,\r\n *     returns the `fallback` value.\r\n *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and\r\n *     `fallback` values must be of the same type, and can be of any kind.\r\n *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between\r\n *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is\r\n *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value\r\n *     of 1 is equivalent to `['linear']`.\r\n *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.\r\n *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised\r\n *     between `output1` and `outputN`.\r\n *   * `['string', value1, value2, ...]` returns the first value in the list that evaluates to a string.\r\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 'default value']]`\r\n *     (Canvas only).\r\n *   * `['number', value1, value2, ...]` returns the first value in the list that evaluates to a number.\r\n *     An example would be to provide a default value for get: `['string', ['get', 'propertyname'], 42]]`\r\n *     (Canvas only).\r\n *   * `['coalesce', value1, value2, ...]` returns the first value in the list which is not null or undefined.\r\n *     An example would be to provide a default value for get: `['coalesce', ['get','propertyname'], 'default value']]`\r\n *     (Canvas only).\r\n *\r\n * * Logical operators:\r\n *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.\r\n *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.\r\n *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.\r\n *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.\r\n *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.\r\n *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.\r\n *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.\r\n *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.\r\n *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.\r\n *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`\r\n *     (inclusively), or `false` otherwise.\r\n *   * `['in', needle, haystack]` returns `true` if `needle` is found in `haystack`, and\r\n *     `false` otherwise.\r\n *     This operator has the following limitations:\r\n *     * `haystack` has to be an array of numbers or strings (searching for a substring in a string is not supported yet)\r\n *     * Only literal arrays are supported as `haystack` for now; this means that `haystack` cannot be the result of an\r\n *     expression. If `haystack` is an array of strings, use the `literal` operator to disambiguate from an expression:\r\n *     `['literal', ['abc', 'def', 'ghi']]`\r\n *\r\n * * Conversion operators:\r\n *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of\r\n *     values can currently only be 2, 3 or 4 (WebGL only).\r\n *   * `['color', red, green, blue, alpha]` or `['color', shade, alpha]` creates a `color` value from `number` values;\r\n *     the `alpha` parameter is optional; if not specified, it will be set to 1 (WebGL only).\r\n *     Note: `red`, `green` and `blue` or `shade` components must be values between 0 and 255; `alpha` between 0 and 1.\r\n *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`\r\n *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors\r\n *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),\r\n *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b\r\n *     in the 0-255 range and a in the 0-1 range) (WebGL only).\r\n *   * `['to-string', value]` converts the input value to a string. If the input is a boolean, the result is \"true\" or \"false\".\r\n *     If the input is a number, it is converted to a string as specified by the \"NumberToString\" algorithm of the ECMAScript\r\n *     Language Specification. If the input is a color, it is converted to a string of the form \"rgba(r,g,b,a)\". (Canvas only)\r\n *\r\n * Values can either be literals or another operator, as they will be evaluated recursively.\r\n * Literal values can be of the following types:\r\n * * `boolean`\r\n * * `number`\r\n * * `number[]` (number arrays can only have a length of 2, 3 or 4)\r\n * * `string`\r\n * * {@link module:ol/color~Color}\r\n *\r\n * @typedef {Array<*>|import(\"../color.js\").Color|string|number|boolean} ExpressionValue\r\n * @api\r\n */\r\n\r\nlet numTypes = 0;\r\nexport const NoneType = 0;\r\nexport const BooleanType = 1 << numTypes++;\r\nexport const NumberType = 1 << numTypes++;\r\nexport const StringType = 1 << numTypes++;\r\nexport const ColorType = 1 << numTypes++;\r\nexport const NumberArrayType = 1 << numTypes++;\r\nexport const SizeType = 1 << numTypes++;\r\nexport const AnyType = Math.pow(2, numTypes) - 1;\r\n\r\nconst typeNames = {\r\n  [BooleanType]: 'boolean',\r\n  [NumberType]: 'number',\r\n  [StringType]: 'string',\r\n  [ColorType]: 'color',\r\n  [NumberArrayType]: 'number[]',\r\n  [SizeType]: 'size',\r\n};\r\n\r\nconst namedTypes = Object.keys(typeNames).map(Number).sort(ascending);\r\n\r\n/**\r\n * Get a string representation for a type.\r\n * @param {number} type The type.\r\n * @return {string} The type name.\r\n */\r\nexport function typeName(type) {\r\n  const names = [];\r\n  for (const namedType of namedTypes) {\r\n    if (includesType(type, namedType)) {\r\n      names.push(typeNames[namedType]);\r\n    }\r\n  }\r\n  if (names.length === 0) {\r\n    return 'untyped';\r\n  }\r\n  if (names.length < 3) {\r\n    return names.join(' or ');\r\n  }\r\n  return names.slice(0, -1).join(', ') + ', or ' + names[names.length - 1];\r\n}\r\n\r\n/**\r\n * @param {number} broad The broad type.\r\n * @param {number} specific The specific type.\r\n * @return {boolean} The broad type includes the specific type.\r\n */\r\nexport function includesType(broad, specific) {\r\n  return (broad & specific) === specific;\r\n}\r\n\r\n/**\r\n * @param {number} oneType One type.\r\n * @param {number} otherType Another type.\r\n * @return {boolean} The set of types overlap (share a common specific type)\r\n */\r\nexport function overlapsType(oneType, otherType) {\r\n  return !!(oneType & otherType);\r\n}\r\n\r\n/**\r\n * @param {number} type The type.\r\n * @param {number} expected The expected type.\r\n * @return {boolean} The given type is exactly the expected type.\r\n */\r\nexport function isType(type, expected) {\r\n  return type === expected;\r\n}\r\n\r\n/**\r\n * @typedef {boolean|number|string|Array<number>} LiteralValue\r\n */\r\n\r\nexport class LiteralExpression {\r\n  /**\r\n   * @param {number} type The value type.\r\n   * @param {LiteralValue} value The literal value.\r\n   */\r\n  constructor(type, value) {\r\n    this.type = type;\r\n    this.value = value;\r\n  }\r\n}\r\n\r\nexport class CallExpression {\r\n  /**\r\n   * @param {number} type The return type.\r\n   * @param {string} operator The operator.\r\n   * @param {...Expression} args The arguments.\r\n   */\r\n  constructor(type, operator, ...args) {\r\n    this.type = type;\r\n    this.operator = operator;\r\n    this.args = args;\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {LiteralExpression|CallExpression} Expression\r\n */\r\n\r\n/**\r\n * @typedef {Object} ParsingContext\r\n * @property {Set<string>} variables Variables referenced with the 'var' operator.\r\n * @property {Set<string>} properties Properties referenced with the 'get' operator.\r\n * @property {boolean} featureId The style uses the feature id.\r\n * @property {boolean} geometryType The style uses the feature geometry type.\r\n * @property {import(\"../style/flat.js\").FlatStyle|import(\"../style/webgl.js\").WebGLStyle} style The style being parsed\r\n */\r\n\r\n/**\r\n * @return {ParsingContext} A new parsing context.\r\n */\r\nexport function newParsingContext() {\r\n  return {\r\n    variables: new Set(),\r\n    properties: new Set(),\r\n    featureId: false,\r\n    geometryType: false,\r\n    style: {},\r\n  };\r\n}\r\n\r\n/**\r\n * @param {string} typeHint Type hint\r\n * @return {number} Resulting value type (will be a single type)\r\n */\r\nfunction getTypeFromHint(typeHint) {\r\n  switch (typeHint) {\r\n    case 'string':\r\n      return StringType;\r\n    case 'color':\r\n      return ColorType;\r\n    case 'number':\r\n      return NumberType;\r\n    case 'boolean':\r\n      return BooleanType;\r\n    case 'number[]':\r\n      return NumberArrayType;\r\n    default:\r\n      throw new Error(`Unrecognized type hint: ${typeHint}`);\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {LiteralValue|Array} EncodedExpression\r\n */\r\n\r\n/**\r\n * @param {EncodedExpression} encoded The encoded expression.\r\n * @param {ParsingContext} context The parsing context.\r\n * @param {number} [typeHint] Optional type hint\r\n * @return {Expression} The parsed expression result.\r\n */\r\nexport function parse(encoded, context, typeHint) {\r\n  switch (typeof encoded) {\r\n    case 'boolean': {\r\n      return new LiteralExpression(BooleanType, encoded);\r\n    }\r\n    case 'number': {\r\n      return new LiteralExpression(\r\n        typeHint === SizeType ? SizeType : NumberType,\r\n        encoded,\r\n      );\r\n    }\r\n    case 'string': {\r\n      let type = StringType;\r\n      if (isStringColor(encoded)) {\r\n        type |= ColorType;\r\n      }\r\n      // apply the given type hint only if it won't result in an empty type\r\n      if (!isType(type & typeHint, NoneType)) {\r\n        type &= typeHint;\r\n      }\r\n      return new LiteralExpression(type, encoded);\r\n    }\r\n    default: {\r\n      // pass\r\n    }\r\n  }\r\n\r\n  if (!Array.isArray(encoded)) {\r\n    throw new Error('Expression must be an array or a primitive value');\r\n  }\r\n\r\n  if (encoded.length === 0) {\r\n    throw new Error('Empty expression');\r\n  }\r\n\r\n  if (typeof encoded[0] === 'string') {\r\n    return parseCallExpression(encoded, context, typeHint);\r\n  }\r\n\r\n  for (const item of encoded) {\r\n    if (typeof item !== 'number') {\r\n      throw new Error('Expected an array of numbers');\r\n    }\r\n  }\r\n\r\n  let type = NumberArrayType;\r\n  if (encoded.length === 2) {\r\n    type |= SizeType;\r\n  } else if (encoded.length === 3 || encoded.length === 4) {\r\n    type |= ColorType;\r\n  }\r\n  if (typeHint) {\r\n    type &= typeHint;\r\n  }\r\n  return new LiteralExpression(type, encoded);\r\n}\r\n\r\n/**\r\n * @type {Object<string, string>}\r\n */\r\nexport const Ops = {\r\n  Get: 'get',\r\n  Var: 'var',\r\n  Concat: 'concat',\r\n  GeometryType: 'geometry-type',\r\n  Any: 'any',\r\n  All: 'all',\r\n  Not: '!',\r\n  Resolution: 'resolution',\r\n  Zoom: 'zoom',\r\n  Time: 'time',\r\n  Equal: '==',\r\n  NotEqual: '!=',\r\n  GreaterThan: '>',\r\n  GreaterThanOrEqualTo: '>=',\r\n  LessThan: '<',\r\n  LessThanOrEqualTo: '<=',\r\n  Multiply: '*',\r\n  Divide: '/',\r\n  Add: '+',\r\n  Subtract: '-',\r\n  Clamp: 'clamp',\r\n  Mod: '%',\r\n  Pow: '^',\r\n  Abs: 'abs',\r\n  Floor: 'floor',\r\n  Ceil: 'ceil',\r\n  Round: 'round',\r\n  Sin: 'sin',\r\n  Cos: 'cos',\r\n  Atan: 'atan',\r\n  Sqrt: 'sqrt',\r\n  Match: 'match',\r\n  Between: 'between',\r\n  Interpolate: 'interpolate',\r\n  Coalesce: 'coalesce',\r\n  Case: 'case',\r\n  In: 'in',\r\n  Number: 'number',\r\n  String: 'string',\r\n  Array: 'array',\r\n  Color: 'color',\r\n  Id: 'id',\r\n  Band: 'band',\r\n  Palette: 'palette',\r\n  ToString: 'to-string',\r\n};\r\n\r\n/**\r\n * @typedef {function(Array, ParsingContext, number):Expression} Parser\r\n * Third argument is a type hint\r\n */\r\n\r\n/**\r\n * @type {Object<string, Parser>}\r\n */\r\nconst parsers = {\r\n  [Ops.Get]: createParser(\r\n    ([_, typeHint]) => {\r\n      if (typeHint !== undefined) {\r\n        return getTypeFromHint(\r\n          /** @type {string} */ (\r\n            /** @type {LiteralExpression} */ (typeHint).value\r\n          ),\r\n        );\r\n      }\r\n      return AnyType;\r\n    },\r\n    withArgsCount(1, 2),\r\n    withGetArgs,\r\n  ),\r\n  [Ops.Var]: createParser(\r\n    ([firstArg]) => firstArg.type,\r\n    withArgsCount(1, 1),\r\n    withVarArgs,\r\n  ),\r\n  [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),\r\n  [Ops.Concat]: createParser(\r\n    StringType,\r\n    withArgsCount(2, Infinity),\r\n    parseArgsOfType(AnyType),\r\n  ),\r\n  [Ops.GeometryType]: createParser(StringType, withNoArgs, usesGeometryType),\r\n  [Ops.Resolution]: createParser(NumberType, withNoArgs),\r\n  [Ops.Zoom]: createParser(NumberType, withNoArgs),\r\n  [Ops.Time]: createParser(NumberType, withNoArgs),\r\n  [Ops.Any]: createParser(\r\n    BooleanType,\r\n    withArgsCount(2, Infinity),\r\n    parseArgsOfType(BooleanType),\r\n  ),\r\n  [Ops.All]: createParser(\r\n    BooleanType,\r\n    withArgsCount(2, Infinity),\r\n    parseArgsOfType(BooleanType),\r\n  ),\r\n  [Ops.Not]: createParser(\r\n    BooleanType,\r\n    withArgsCount(1, 1),\r\n    parseArgsOfType(BooleanType),\r\n  ),\r\n  [Ops.Equal]: createParser(\r\n    BooleanType,\r\n    withArgsCount(2, 2),\r\n    parseArgsOfType(AnyType),\r\n    narrowArgsType,\r\n  ),\r\n  [Ops.NotEqual]: createParser(\r\n    BooleanType,\r\n    withArgsCount(2, 2),\r\n    parseArgsOfType(AnyType),\r\n    narrowArgsType,\r\n  ),\r\n  [Ops.GreaterThan]: createParser(\r\n    BooleanType,\r\n    withArgsCount(2, 2),\r\n    parseArgsOfType(AnyType),\r\n    narrowArgsType,\r\n  ),\r\n  [Ops.GreaterThanOrEqualTo]: createParser(\r\n    BooleanType,\r\n    withArgsCount(2, 2),\r\n    parseArgsOfType(AnyType),\r\n    narrowArgsType,\r\n  ),\r\n  [Ops.LessThan]: createParser(\r\n    BooleanType,\r\n    withArgsCount(2, 2),\r\n    parseArgsOfType(AnyType),\r\n    narrowArgsType,\r\n  ),\r\n  [Ops.LessThanOrEqualTo]: createParser(\r\n    BooleanType,\r\n    withArgsCount(2, 2),\r\n    parseArgsOfType(AnyType),\r\n    narrowArgsType,\r\n  ),\r\n  [Ops.Multiply]: createParser(\r\n    (parsedArgs) => {\r\n      let outputType = NumberType | ColorType;\r\n      for (let i = 0; i < parsedArgs.length; i++) {\r\n        outputType &= parsedArgs[i].type;\r\n      }\r\n      return outputType;\r\n    },\r\n    withArgsCount(2, Infinity),\r\n    parseArgsOfType(NumberType | ColorType),\r\n    narrowArgsType,\r\n  ),\r\n  [Ops.Coalesce]: createParser(\r\n    (parsedArgs) => {\r\n      let type = AnyType;\r\n      for (let i = 1; i < parsedArgs.length; i += 2) {\r\n        type &= parsedArgs[i].type;\r\n      }\r\n      type &= parsedArgs[parsedArgs.length - 1].type;\r\n      return type;\r\n    },\r\n    withArgsCount(2, Infinity),\r\n    parseArgsOfType(AnyType),\r\n    narrowArgsType,\r\n  ),\r\n  [Ops.Divide]: createParser(\r\n    NumberType,\r\n    withArgsCount(2, 2),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Add]: createParser(\r\n    NumberType,\r\n    withArgsCount(2, Infinity),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Subtract]: createParser(\r\n    NumberType,\r\n    withArgsCount(2, 2),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Clamp]: createParser(\r\n    NumberType,\r\n    withArgsCount(3, 3),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Mod]: createParser(\r\n    NumberType,\r\n    withArgsCount(2, 2),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Pow]: createParser(\r\n    NumberType,\r\n    withArgsCount(2, 2),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Abs]: createParser(\r\n    NumberType,\r\n    withArgsCount(1, 1),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Floor]: createParser(\r\n    NumberType,\r\n    withArgsCount(1, 1),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Ceil]: createParser(\r\n    NumberType,\r\n    withArgsCount(1, 1),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Round]: createParser(\r\n    NumberType,\r\n    withArgsCount(1, 1),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Sin]: createParser(\r\n    NumberType,\r\n    withArgsCount(1, 1),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Cos]: createParser(\r\n    NumberType,\r\n    withArgsCount(1, 1),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Atan]: createParser(\r\n    NumberType,\r\n    withArgsCount(1, 2),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Sqrt]: createParser(\r\n    NumberType,\r\n    withArgsCount(1, 1),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Match]: createParser(\r\n    (parsedArgs) => {\r\n      let type = AnyType;\r\n      for (let i = 2; i < parsedArgs.length; i += 2) {\r\n        type &= parsedArgs[i].type;\r\n      }\r\n      type &= parsedArgs[parsedArgs.length - 1].type;\r\n      return type;\r\n    },\r\n    withArgsCount(4, Infinity),\r\n    withEvenArgs,\r\n    parseMatchArgs,\r\n  ),\r\n  [Ops.Between]: createParser(\r\n    BooleanType,\r\n    withArgsCount(3, 3),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Interpolate]: createParser(\r\n    (parsedArgs) => {\r\n      let type = ColorType | NumberType;\r\n      for (let i = 3; i < parsedArgs.length; i += 2) {\r\n        type &= parsedArgs[i].type;\r\n      }\r\n      return type;\r\n    },\r\n    withArgsCount(6, Infinity),\r\n    withEvenArgs,\r\n    parseInterpolateArgs,\r\n  ),\r\n  [Ops.Case]: createParser(\r\n    (parsedArgs) => {\r\n      let type = AnyType;\r\n      for (let i = 1; i < parsedArgs.length; i += 2) {\r\n        type &= parsedArgs[i].type;\r\n      }\r\n      type &= parsedArgs[parsedArgs.length - 1].type;\r\n      return type;\r\n    },\r\n    withArgsCount(3, Infinity),\r\n    withOddArgs,\r\n    parseCaseArgs,\r\n  ),\r\n  [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),\r\n  [Ops.Number]: createParser(\r\n    NumberType,\r\n    withArgsCount(1, Infinity),\r\n    parseArgsOfType(AnyType),\r\n  ),\r\n  [Ops.String]: createParser(\r\n    StringType,\r\n    withArgsCount(1, Infinity),\r\n    parseArgsOfType(AnyType),\r\n  ),\r\n  [Ops.Array]: createParser(\r\n    (parsedArgs) => {\r\n      return parsedArgs.length === 2\r\n        ? NumberArrayType | SizeType\r\n        : parsedArgs.length === 3 || parsedArgs.length === 4\r\n          ? NumberArrayType | ColorType\r\n          : NumberArrayType;\r\n    },\r\n    withArgsCount(1, Infinity),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Color]: createParser(\r\n    ColorType,\r\n    withArgsCount(1, 4),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Band]: createParser(\r\n    NumberType,\r\n    withArgsCount(1, 3),\r\n    parseArgsOfType(NumberType),\r\n  ),\r\n  [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs),\r\n  [Ops.ToString]: createParser(\r\n    StringType,\r\n    withArgsCount(1, 1),\r\n    parseArgsOfType(BooleanType | NumberType | StringType | ColorType),\r\n  ),\r\n};\r\n\r\n/**\r\n * @typedef {function(Array<EncodedExpression>, ParsingContext, Array<Expression>, number?):Array<Expression>|void} ArgValidator\r\n * An argument validator applies various checks to an encoded expression arguments\r\n * Returns the parsed arguments if any.\r\n * Third argument is the array of parsed arguments from previous validators\r\n * Fourth argument is an optional type hint\r\n */\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withGetArgs(encoded, context) {\r\n  const arg = parse(encoded[1], context);\r\n  if (!(arg instanceof LiteralExpression)) {\r\n    throw new Error('Expected a literal argument for get operation');\r\n  }\r\n  if (typeof arg.value !== 'string') {\r\n    throw new Error('Expected a string argument for get operation');\r\n  }\r\n  context.properties.add(arg.value);\r\n  if (encoded.length === 3) {\r\n    const hint = parse(encoded[2], context);\r\n    return [arg, hint];\r\n  }\r\n  return [arg];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withVarArgs(encoded, context, parsedArgs, typeHint) {\r\n  const varName = encoded[1];\r\n  if (typeof varName !== 'string') {\r\n    throw new Error('Expected a string argument for var operation');\r\n  }\r\n  context.variables.add(varName);\r\n  if (\r\n    !('variables' in context.style) ||\r\n    context.style.variables[varName] === undefined\r\n  ) {\r\n    return [new LiteralExpression(AnyType, varName)];\r\n  }\r\n  const initialValue = context.style.variables[varName];\r\n  const arg = /** @type {LiteralExpression} */ (parse(initialValue, context));\r\n  arg.value = varName;\r\n  if (typeHint && !overlapsType(typeHint, arg.type)) {\r\n    throw new Error(\r\n      `The variable ${varName} has type ${typeName(\r\n        arg.type,\r\n      )} but the following type was expected: ${typeName(typeHint)}`,\r\n    );\r\n  }\r\n  return [arg];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction usesFeatureId(encoded, context) {\r\n  context.featureId = true;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction usesGeometryType(encoded, context) {\r\n  context.geometryType = true;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction withNoArgs(encoded, context) {\r\n  const operation = encoded[0];\r\n  if (encoded.length !== 1) {\r\n    throw new Error(`Expected no arguments for ${operation} operation`);\r\n  }\r\n  return [];\r\n}\r\n\r\n/**\r\n * @param {number} minArgs The minimum number of arguments.\r\n * @param {number} maxArgs The maximum number of arguments.\r\n * @return {ArgValidator} The argument validator\r\n */\r\nfunction withArgsCount(minArgs, maxArgs) {\r\n  return function (encoded, context) {\r\n    const operation = encoded[0];\r\n    const argCount = encoded.length - 1;\r\n    if (minArgs === maxArgs) {\r\n      if (argCount !== minArgs) {\r\n        const plural = minArgs === 1 ? '' : 's';\r\n        throw new Error(\r\n          `Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`,\r\n        );\r\n      }\r\n    } else if (argCount < minArgs || argCount > maxArgs) {\r\n      const range =\r\n        maxArgs === Infinity\r\n          ? `${minArgs} or more`\r\n          : `${minArgs} to ${maxArgs}`;\r\n      throw new Error(\r\n        `Expected ${range} arguments for ${operation}, got ${argCount}`,\r\n      );\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * @param {number} argType The argument type.\r\n * @return {ArgValidator} The argument validator\r\n */\r\nfunction parseArgsOfType(argType) {\r\n  return function (encoded, context) {\r\n    const operation = encoded[0];\r\n    const argCount = encoded.length - 1;\r\n    /**\r\n     * @type {Array<Expression>}\r\n     */\r\n    const args = new Array(argCount);\r\n    for (let i = 0; i < argCount; ++i) {\r\n      const expression = parse(encoded[i + 1], context);\r\n      if (!overlapsType(argType, expression.type)) {\r\n        const gotType = typeName(argType);\r\n        const expectedType = typeName(expression.type);\r\n        throw new Error(\r\n          `Unexpected type for argument ${i} of ${operation} operation` +\r\n            `, got ${gotType} but expected ${expectedType}`,\r\n        );\r\n      }\r\n      expression.type &= argType;\r\n      args[i] = expression;\r\n    }\r\n    return args;\r\n  };\r\n}\r\n\r\n/**\r\n * @type {ArgValidator}\r\n */\r\nfunction narrowArgsType(encoded, context, parsedArgs) {\r\n  const operation = encoded[0];\r\n  const argCount = encoded.length - 1;\r\n\r\n  // first pass to determine a narrowed down type\r\n  let sameType = AnyType;\r\n  for (let i = 0; i < parsedArgs.length; ++i) {\r\n    sameType &= parsedArgs[i].type;\r\n  }\r\n\r\n  if (sameType === NoneType) {\r\n    throw new Error(\r\n      `No common type could be found for arguments of ${operation} operation`,\r\n    );\r\n  }\r\n\r\n  // re-parse args\r\n  const args = new Array(argCount);\r\n  for (let i = 0; i < argCount; ++i) {\r\n    args[i] = parse(encoded[i + 1], context, sameType);\r\n  }\r\n  return args;\r\n}\r\n\r\n/**\r\n * @type {ArgValidator}\r\n */\r\nfunction withOddArgs(encoded, context) {\r\n  const operation = encoded[0];\r\n  const argCount = encoded.length - 1;\r\n  if (argCount % 2 === 0) {\r\n    throw new Error(\r\n      `An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\r\n        argCount,\r\n      )} instead`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @type {ArgValidator}\r\n */\r\nfunction withEvenArgs(encoded, context) {\r\n  const operation = encoded[0];\r\n  const argCount = encoded.length - 1;\r\n  if (argCount % 2 === 1) {\r\n    throw new Error(\r\n      `An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(\r\n        argCount,\r\n      )} instead`,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction parseMatchArgs(encoded, context, parsedArgs, typeHint) {\r\n  const argsCount = encoded.length - 1;\r\n\r\n  const input = parse(encoded[1], context);\r\n  let inputType = input.type;\r\n  const fallback = parse(encoded[encoded.length - 1], context);\r\n  let outputType =\r\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\r\n\r\n  // first parse args to figure out possible types\r\n  const args = new Array(argsCount - 2);\r\n  for (let i = 0; i < argsCount - 2; i += 2) {\r\n    const match = parse(encoded[i + 2], context);\r\n    const output = parse(encoded[i + 3], context);\r\n    inputType &= match.type;\r\n    outputType &= output.type;\r\n    args[i] = match;\r\n    args[i + 1] = output;\r\n  }\r\n\r\n  // check input and output types validity\r\n  const expectedInputType = StringType | NumberType | BooleanType;\r\n  if (!overlapsType(expectedInputType, inputType)) {\r\n    throw new Error(\r\n      `Expected an input of type ${typeName(\r\n        expectedInputType,\r\n      )} for the interpolate operation` +\r\n        `, got ${typeName(inputType)} instead`,\r\n    );\r\n  }\r\n  inputType &= expectedInputType;\r\n  if (isType(outputType, NoneType)) {\r\n    throw new Error(\r\n      `Could not find a common output type for the following match operation: ` +\r\n        JSON.stringify(encoded),\r\n    );\r\n  }\r\n\r\n  // parse again inputs and outputs with common type\r\n  for (let i = 0; i < argsCount - 2; i += 2) {\r\n    const match = parse(encoded[i + 2], context, inputType);\r\n    const output = parse(encoded[i + 3], context, outputType);\r\n    args[i] = match;\r\n    args[i + 1] = output;\r\n  }\r\n\r\n  return [\r\n    parse(encoded[1], context, inputType),\r\n    ...args,\r\n    parse(encoded[encoded.length - 1], context, outputType),\r\n  ];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {\r\n  const interpolationType = encoded[1];\r\n  let interpolation;\r\n  switch (interpolationType[0]) {\r\n    case 'linear':\r\n      interpolation = 1;\r\n      break;\r\n    case 'exponential':\r\n      interpolation = interpolationType[1];\r\n      if (typeof interpolation !== 'number') {\r\n        throw new Error(\r\n          `Expected a number base for exponential interpolation` +\r\n            `, got ${JSON.stringify(interpolation)} instead`,\r\n        );\r\n      }\r\n      break;\r\n    default:\r\n      interpolation = null;\r\n  }\r\n  if (!interpolation) {\r\n    throw new Error(\r\n      `Invalid interpolation type: ${JSON.stringify(interpolationType)}`,\r\n    );\r\n  }\r\n  interpolation = parse(interpolation, context);\r\n\r\n  // check input types\r\n  let input = parse(encoded[2], context);\r\n  if (!overlapsType(NumberType, input.type)) {\r\n    throw new Error(\r\n      `Expected an input of type number for the interpolate operation` +\r\n        `, got ${typeName(input.type)} instead`,\r\n    );\r\n  }\r\n  input = parse(encoded[2], context, NumberType); // parse again with narrower output\r\n\r\n  const args = new Array(encoded.length - 3);\r\n  for (let i = 0; i < args.length; i += 2) {\r\n    let stop = parse(encoded[i + 3], context);\r\n    if (!overlapsType(NumberType, stop.type)) {\r\n      throw new Error(\r\n        `Expected all stop input values in the interpolate operation to be of type number` +\r\n          `, got ${typeName(stop.type)} at position ${i + 2} instead`,\r\n      );\r\n    }\r\n    let output = parse(encoded[i + 4], context);\r\n    if (!overlapsType(NumberType | ColorType, output.type)) {\r\n      throw new Error(\r\n        `Expected all stop output values in the interpolate operation to be a number or color` +\r\n          `, got ${typeName(output.type)} at position ${i + 3} instead`,\r\n      );\r\n    }\r\n    // parse again with narrower types\r\n    stop = parse(encoded[i + 3], context, NumberType);\r\n    output = parse(encoded[i + 4], context, NumberType | ColorType);\r\n    args[i] = stop;\r\n    args[i + 1] = output;\r\n  }\r\n\r\n  return [interpolation, input, ...args];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction parseCaseArgs(encoded, context, parsedArgs, typeHint) {\r\n  const fallback = parse(encoded[encoded.length - 1], context, typeHint);\r\n  let outputType =\r\n    typeHint !== undefined ? typeHint & fallback.type : fallback.type;\r\n\r\n  // first parse args to figure out possible types\r\n  const args = new Array(encoded.length - 1);\r\n  for (let i = 0; i < args.length - 1; i += 2) {\r\n    const condition = parse(encoded[i + 1], context);\r\n    const output = parse(encoded[i + 2], context, typeHint);\r\n    if (!overlapsType(BooleanType, condition.type)) {\r\n      throw new Error(\r\n        `Expected all conditions in the case operation to be of type boolean` +\r\n          `, got ${typeName(condition.type)} at position ${i} instead`,\r\n      );\r\n    }\r\n    outputType &= output.type;\r\n    args[i] = condition;\r\n    args[i + 1] = output;\r\n  }\r\n\r\n  if (isType(outputType, NoneType)) {\r\n    throw new Error(\r\n      `Could not find a common output type for the following case operation: ` +\r\n        JSON.stringify(encoded),\r\n    );\r\n  }\r\n\r\n  // parse again args with common output type\r\n  for (let i = 0; i < args.length - 1; i += 2) {\r\n    args[i + 1] = parse(encoded[i + 2], context, outputType);\r\n  }\r\n  args[args.length - 1] = parse(\r\n    encoded[encoded.length - 1],\r\n    context,\r\n    outputType,\r\n  );\r\n\r\n  return args;\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction parseInArgs(encoded, context) {\r\n  /** @type {Array<number|string>} */\r\n  let haystack = /** @type {any} */ (encoded[2]);\r\n  if (!Array.isArray(haystack)) {\r\n    throw new Error(\r\n      `The \"in\" operator was provided a literal value which was not an array as second argument.`,\r\n    );\r\n  }\r\n  if (typeof haystack[0] === 'string') {\r\n    if (haystack[0] !== 'literal') {\r\n      throw new Error(\r\n        `For the \"in\" operator, a string array should be wrapped in a \"literal\" operator to disambiguate from expressions.`,\r\n      );\r\n    }\r\n    if (!Array.isArray(haystack[1])) {\r\n      throw new Error(\r\n        `The \"in\" operator was provided a literal value which was not an array as second argument.`,\r\n      );\r\n    }\r\n    haystack = haystack[1];\r\n  }\r\n\r\n  let needleType = StringType | NumberType;\r\n  const args = new Array(haystack.length);\r\n  for (let i = 0; i < args.length; i++) {\r\n    const arg = parse(haystack[i], context);\r\n    needleType &= arg.type;\r\n    args[i] = arg;\r\n  }\r\n  if (isType(needleType, NoneType)) {\r\n    throw new Error(\r\n      `Could not find a common type for the following in operation: ` +\r\n        JSON.stringify(encoded),\r\n    );\r\n  }\r\n\r\n  const needle = parse(encoded[1], context, needleType);\r\n  return [needle, ...args];\r\n}\r\n\r\n/**\r\n * @type ArgValidator\r\n */\r\nfunction parsePaletteArgs(encoded, context) {\r\n  const index = parse(encoded[1], context, NumberType);\r\n  if (index.type !== NumberType) {\r\n    throw new Error(\r\n      `The first argument of palette must be an number, got ${typeName(\r\n        index.type,\r\n      )} instead`,\r\n    );\r\n  }\r\n  const colors = encoded[2];\r\n  if (!Array.isArray(colors)) {\r\n    throw new Error('The second argument of palette must be an array');\r\n  }\r\n  const parsedColors = new Array(colors.length);\r\n  for (let i = 0; i < parsedColors.length; i++) {\r\n    const color = parse(colors[i], context, ColorType);\r\n    if (!(color instanceof LiteralExpression)) {\r\n      throw new Error(\r\n        `The palette color at index ${i} must be a literal value`,\r\n      );\r\n    }\r\n    if (!overlapsType(color.type, ColorType)) {\r\n      throw new Error(\r\n        `The palette color at index ${i} should be of type color, got ${typeName(\r\n          color.type,\r\n        )} instead`,\r\n      );\r\n    }\r\n    parsedColors[i] = color;\r\n  }\r\n  return [index, ...parsedColors];\r\n}\r\n\r\n/**\r\n * @param {number|function(Array<Expression>):number} returnType The return type of the operator; can be a fixed value or a callback taking the parsed\r\n * arguments\r\n * @param {Array<ArgValidator>} argValidators A chain of argument validators; the return value of the last validator\r\n * will be used as parsed arguments\r\n * @return {Parser} The parser.\r\n */\r\nfunction createParser(returnType, ...argValidators) {\r\n  return function (encoded, context, typeHint) {\r\n    const operator = encoded[0];\r\n    let parsedArgs = [];\r\n    for (let i = 0; i < argValidators.length; i++) {\r\n      parsedArgs =\r\n        argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;\r\n    }\r\n    let actualType =\r\n      typeof returnType === 'function' ? returnType(parsedArgs) : returnType;\r\n    if (typeHint !== undefined) {\r\n      if (!overlapsType(actualType, typeHint)) {\r\n        throw new Error(\r\n          `The following expression was expected to return ${typeName(\r\n            typeHint,\r\n          )}, but returns ${typeName(actualType)} instead: ${JSON.stringify(\r\n            encoded,\r\n          )}`,\r\n        );\r\n      }\r\n      actualType &= typeHint;\r\n    }\r\n    if (actualType === NoneType) {\r\n      throw new Error(\r\n        `No matching type was found for the following expression: ${JSON.stringify(\r\n          encoded,\r\n        )}`,\r\n      );\r\n    }\r\n    return new CallExpression(actualType, operator, ...parsedArgs);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {Array} encoded The encoded expression.\r\n * @param {ParsingContext} context The parsing context.\r\n * @param {number} [typeHint] Optional type hint\r\n * @return {Expression} The parsed expression.\r\n */\r\nfunction parseCallExpression(encoded, context, typeHint) {\r\n  const operator = encoded[0];\r\n\r\n  const parser = parsers[operator];\r\n  if (!parser) {\r\n    throw new Error(`Unknown operator: ${operator}`);\r\n  }\r\n  return parser(encoded, context, typeHint);\r\n}\r\n\r\n/**\r\n * Returns a simplified geometry type suited for the `geometry-type` operator\r\n * @param {import('../geom/Geometry.js').default|import('../render/Feature.js').default} geometry Geometry object\r\n * @return {'Point'|'LineString'|'Polygon'|''} Simplified geometry type; empty string of no geometry found\r\n */\r\nexport function computeGeometryType(geometry) {\r\n  if (!geometry) {\r\n    return '';\r\n  }\r\n  const type = geometry.getType();\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'LineString':\r\n    case 'Polygon':\r\n      return type;\r\n    case 'MultiPoint':\r\n    case 'MultiLineString':\r\n    case 'MultiPolygon':\r\n      return /** @type {'Point'|'LineString'|'Polygon'} */ (type.substring(5));\r\n    case 'Circle':\r\n      return 'Polygon';\r\n    case 'GeometryCollection':\r\n      return computeGeometryType(\r\n        /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries()[0],\r\n      );\r\n    default:\r\n      return '';\r\n  }\r\n}\r\n", "/**\r\n * @module ol/expr/cpu\r\n */\r\n\r\nimport {\r\n  ColorType,\r\n  LiteralExpression,\r\n  Ops,\r\n  overlapsType,\r\n  parse,\r\n  typeName,\r\n} from './expression.js';\r\nimport {\r\n  fromString,\r\n  lchaToRgba,\r\n  normalize,\r\n  rgbaToLcha,\r\n  toString,\r\n  withAlpha,\r\n} from '../color.js';\r\n\r\n/**\r\n * @fileoverview This module includes functions to build expressions for evaluation on the CPU.\r\n * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded\r\n * expression and returns an instance of one of the expression classes.  The compiling step takes\r\n * the expression instance and returns a function that can be evaluated in to return a literal\r\n * value.  The evaluator function should do as little allocation and work as possible.\r\n */\r\n\r\n/**\r\n * @typedef {Object} EvaluationContext\r\n * @property {Object} properties The values for properties used in 'get' expressions.\r\n * @property {Object} variables The values for variables used in 'var' expressions.\r\n * @property {number} resolution The map resolution.\r\n * @property {string|number|null} featureId The feature id.\r\n * @property {string} geometryType Geometry type of the current object.\r\n */\r\n\r\n/**\r\n * @return {EvaluationContext} A new evaluation context.\r\n */\r\nexport function newEvaluationContext() {\r\n  return {\r\n    variables: {},\r\n    properties: {},\r\n    resolution: NaN,\r\n    featureId: null,\r\n    geometryType: '',\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):import(\"./expression.js\").LiteralValue} ExpressionEvaluator\r\n */\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):boolean} BooleanEvaluator\r\n */\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):number} NumberEvaluator\r\n */\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):string} StringEvaluator\r\n */\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator\r\n */\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator\r\n */\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator\r\n */\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):(Array<number>)} SizeEvaluator\r\n */\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator\r\n */\r\n\r\n/**\r\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\r\n * @param {number} type The expected type.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {ExpressionEvaluator} The expression evaluator.\r\n */\r\nexport function buildExpression(encoded, type, context) {\r\n  const expression = parse(encoded, context);\r\n  if (!overlapsType(type, expression.type)) {\r\n    const expected = typeName(type);\r\n    const actual = typeName(expression.type);\r\n    throw new Error(\r\n      `Expected expression to be of type ${expected}, got ${actual}`,\r\n    );\r\n  }\r\n  return compileExpression(expression, context);\r\n}\r\n\r\n/**\r\n * @param {import(\"./expression.js\").Expression} expression The expression.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {ExpressionEvaluator} The evaluator function.\r\n */\r\nfunction compileExpression(expression, context) {\r\n  if (expression instanceof LiteralExpression) {\r\n    // convert colors to array if possible\r\n    if (expression.type === ColorType && typeof expression.value === 'string') {\r\n      const colorValue = fromString(expression.value);\r\n      return function () {\r\n        return colorValue;\r\n      };\r\n    }\r\n    return function () {\r\n      return expression.value;\r\n    };\r\n  }\r\n  const operator = expression.operator;\r\n  switch (operator) {\r\n    case Ops.Number:\r\n    case Ops.String:\r\n    case Ops.Coalesce: {\r\n      return compileAssertionExpression(expression, context);\r\n    }\r\n    case Ops.Get:\r\n    case Ops.Var: {\r\n      return compileAccessorExpression(expression, context);\r\n    }\r\n    case Ops.Id: {\r\n      return (context) => context.featureId;\r\n    }\r\n    case Ops.GeometryType: {\r\n      return (context) => context.geometryType;\r\n    }\r\n    case Ops.Concat: {\r\n      const args = expression.args.map((e) => compileExpression(e, context));\r\n      return (context) =>\r\n        ''.concat(...args.map((arg) => arg(context).toString()));\r\n    }\r\n    case Ops.Resolution: {\r\n      return (context) => context.resolution;\r\n    }\r\n    case Ops.Any:\r\n    case Ops.All:\r\n    case Ops.Between:\r\n    case Ops.In:\r\n    case Ops.Not: {\r\n      return compileLogicalExpression(expression, context);\r\n    }\r\n    case Ops.Equal:\r\n    case Ops.NotEqual:\r\n    case Ops.LessThan:\r\n    case Ops.LessThanOrEqualTo:\r\n    case Ops.GreaterThan:\r\n    case Ops.GreaterThanOrEqualTo: {\r\n      return compileComparisonExpression(expression, context);\r\n    }\r\n    case Ops.Multiply:\r\n    case Ops.Divide:\r\n    case Ops.Add:\r\n    case Ops.Subtract:\r\n    case Ops.Clamp:\r\n    case Ops.Mod:\r\n    case Ops.Pow:\r\n    case Ops.Abs:\r\n    case Ops.Floor:\r\n    case Ops.Ceil:\r\n    case Ops.Round:\r\n    case Ops.Sin:\r\n    case Ops.Cos:\r\n    case Ops.Atan:\r\n    case Ops.Sqrt: {\r\n      return compileNumericExpression(expression, context);\r\n    }\r\n    case Ops.Case: {\r\n      return compileCaseExpression(expression, context);\r\n    }\r\n    case Ops.Match: {\r\n      return compileMatchExpression(expression, context);\r\n    }\r\n    case Ops.Interpolate: {\r\n      return compileInterpolateExpression(expression, context);\r\n    }\r\n    case Ops.ToString: {\r\n      return compileConvertExpression(expression, context);\r\n    }\r\n    default: {\r\n      throw new Error(`Unsupported operator ${operator}`);\r\n    }\r\n    // TODO: unimplemented\r\n    // Ops.Zoom\r\n    // Ops.Time\r\n    // Ops.Array\r\n    // Ops.Color\r\n    // Ops.Band\r\n    // Ops.Palette\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import('./expression.js').CallExpression} expression The call expression.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {ExpressionEvaluator} The evaluator function.\r\n */\r\nfunction compileAssertionExpression(expression, context) {\r\n  const type = expression.operator;\r\n  const length = expression.args.length;\r\n\r\n  const args = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    args[i] = compileExpression(expression.args[i], context);\r\n  }\r\n  switch (type) {\r\n    case Ops.Coalesce: {\r\n      return (context) => {\r\n        for (let i = 0; i < length; ++i) {\r\n          const value = args[i](context);\r\n          if (typeof value !== 'undefined' && value !== null) {\r\n            return value;\r\n          }\r\n        }\r\n        throw new Error('Expected one of the values to be non-null');\r\n      };\r\n    }\r\n    case Ops.Number:\r\n    case Ops.String: {\r\n      return (context) => {\r\n        for (let i = 0; i < length; ++i) {\r\n          const value = args[i](context);\r\n          if (typeof value === type) {\r\n            return value;\r\n          }\r\n        }\r\n        throw new Error(`Expected one of the values to be a ${type}`);\r\n      };\r\n    }\r\n    default: {\r\n      throw new Error(`Unsupported assertion operator ${type}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import('./expression.js').CallExpression} expression The call expression.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {ExpressionEvaluator} The evaluator function.\r\n */\r\nfunction compileAccessorExpression(expression, context) {\r\n  const nameExpression = /** @type {LiteralExpression} */ (expression.args[0]);\r\n  const name = /** @type {string} */ (nameExpression.value);\r\n  switch (expression.operator) {\r\n    case Ops.Get: {\r\n      return (context) => context.properties[name];\r\n    }\r\n    case Ops.Var: {\r\n      return (context) => context.variables[name];\r\n    }\r\n    default: {\r\n      throw new Error(`Unsupported accessor operator ${expression.operator}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import('./expression.js').CallExpression} expression The call expression.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {BooleanEvaluator} The evaluator function.\r\n */\r\nfunction compileComparisonExpression(expression, context) {\r\n  const op = expression.operator;\r\n  const left = compileExpression(expression.args[0], context);\r\n  const right = compileExpression(expression.args[1], context);\r\n  switch (op) {\r\n    case Ops.Equal: {\r\n      return (context) => left(context) === right(context);\r\n    }\r\n    case Ops.NotEqual: {\r\n      return (context) => left(context) !== right(context);\r\n    }\r\n    case Ops.LessThan: {\r\n      return (context) => left(context) < right(context);\r\n    }\r\n    case Ops.LessThanOrEqualTo: {\r\n      return (context) => left(context) <= right(context);\r\n    }\r\n    case Ops.GreaterThan: {\r\n      return (context) => left(context) > right(context);\r\n    }\r\n    case Ops.GreaterThanOrEqualTo: {\r\n      return (context) => left(context) >= right(context);\r\n    }\r\n    default: {\r\n      throw new Error(`Unsupported comparison operator ${op}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import('./expression.js').CallExpression} expression The call expression.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {BooleanEvaluator} The evaluator function.\r\n */\r\nfunction compileLogicalExpression(expression, context) {\r\n  const op = expression.operator;\r\n  const length = expression.args.length;\r\n\r\n  const args = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    args[i] = compileExpression(expression.args[i], context);\r\n  }\r\n  switch (op) {\r\n    case Ops.Any: {\r\n      return (context) => {\r\n        for (let i = 0; i < length; ++i) {\r\n          if (args[i](context)) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n    }\r\n    case Ops.All: {\r\n      return (context) => {\r\n        for (let i = 0; i < length; ++i) {\r\n          if (!args[i](context)) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      };\r\n    }\r\n    case Ops.Between: {\r\n      return (context) => {\r\n        const value = args[0](context);\r\n        const min = args[1](context);\r\n        const max = args[2](context);\r\n        return value >= min && value <= max;\r\n      };\r\n    }\r\n    case Ops.In: {\r\n      return (context) => {\r\n        const value = args[0](context);\r\n        for (let i = 1; i < length; ++i) {\r\n          if (value === args[i](context)) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n    }\r\n    case Ops.Not: {\r\n      return (context) => !args[0](context);\r\n    }\r\n    default: {\r\n      throw new Error(`Unsupported logical operator ${op}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import('./expression.js').CallExpression} expression The call expression.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {NumberEvaluator} The evaluator function.\r\n */\r\nfunction compileNumericExpression(expression, context) {\r\n  const op = expression.operator;\r\n  const length = expression.args.length;\r\n\r\n  const args = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    args[i] = compileExpression(expression.args[i], context);\r\n  }\r\n  switch (op) {\r\n    case Ops.Multiply: {\r\n      return (context) => {\r\n        let value = 1;\r\n        for (let i = 0; i < length; ++i) {\r\n          value *= args[i](context);\r\n        }\r\n        return value;\r\n      };\r\n    }\r\n    case Ops.Divide: {\r\n      return (context) => args[0](context) / args[1](context);\r\n    }\r\n    case Ops.Add: {\r\n      return (context) => {\r\n        let value = 0;\r\n        for (let i = 0; i < length; ++i) {\r\n          value += args[i](context);\r\n        }\r\n        return value;\r\n      };\r\n    }\r\n    case Ops.Subtract: {\r\n      return (context) => args[0](context) - args[1](context);\r\n    }\r\n    case Ops.Clamp: {\r\n      return (context) => {\r\n        const value = args[0](context);\r\n        const min = args[1](context);\r\n        if (value < min) {\r\n          return min;\r\n        }\r\n        const max = args[2](context);\r\n        if (value > max) {\r\n          return max;\r\n        }\r\n        return value;\r\n      };\r\n    }\r\n    case Ops.Mod: {\r\n      return (context) => args[0](context) % args[1](context);\r\n    }\r\n    case Ops.Pow: {\r\n      return (context) => Math.pow(args[0](context), args[1](context));\r\n    }\r\n    case Ops.Abs: {\r\n      return (context) => Math.abs(args[0](context));\r\n    }\r\n    case Ops.Floor: {\r\n      return (context) => Math.floor(args[0](context));\r\n    }\r\n    case Ops.Ceil: {\r\n      return (context) => Math.ceil(args[0](context));\r\n    }\r\n    case Ops.Round: {\r\n      return (context) => Math.round(args[0](context));\r\n    }\r\n    case Ops.Sin: {\r\n      return (context) => Math.sin(args[0](context));\r\n    }\r\n    case Ops.Cos: {\r\n      return (context) => Math.cos(args[0](context));\r\n    }\r\n    case Ops.Atan: {\r\n      if (length === 2) {\r\n        return (context) => Math.atan2(args[0](context), args[1](context));\r\n      }\r\n      return (context) => Math.atan(args[0](context));\r\n    }\r\n    case Ops.Sqrt: {\r\n      return (context) => Math.sqrt(args[0](context));\r\n    }\r\n    default: {\r\n      throw new Error(`Unsupported numeric operator ${op}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {import('./expression.js').CallExpression} expression The call expression.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {ExpressionEvaluator} The evaluator function.\r\n */\r\nfunction compileCaseExpression(expression, context) {\r\n  const length = expression.args.length;\r\n  const args = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    args[i] = compileExpression(expression.args[i], context);\r\n  }\r\n  return (context) => {\r\n    for (let i = 0; i < length - 1; i += 2) {\r\n      const condition = args[i](context);\r\n      if (condition) {\r\n        return args[i + 1](context);\r\n      }\r\n    }\r\n    return args[length - 1](context);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {import('./expression.js').CallExpression} expression The call expression.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {ExpressionEvaluator} The evaluator function.\r\n */\r\nfunction compileMatchExpression(expression, context) {\r\n  const length = expression.args.length;\r\n  const args = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    args[i] = compileExpression(expression.args[i], context);\r\n  }\r\n  return (context) => {\r\n    const value = args[0](context);\r\n    for (let i = 1; i < length; i += 2) {\r\n      if (value === args[i](context)) {\r\n        return args[i + 1](context);\r\n      }\r\n    }\r\n    return args[length - 1](context);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {import('./expression.js').CallExpression} expression The call expression.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {ExpressionEvaluator} The evaluator function.\r\n */\r\nfunction compileInterpolateExpression(expression, context) {\r\n  const length = expression.args.length;\r\n  const args = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    args[i] = compileExpression(expression.args[i], context);\r\n  }\r\n  return (context) => {\r\n    const base = args[0](context);\r\n    const value = args[1](context);\r\n\r\n    let previousInput;\r\n    let previousOutput;\r\n    for (let i = 2; i < length; i += 2) {\r\n      const input = args[i](context);\r\n      let output = args[i + 1](context);\r\n      const isColor = Array.isArray(output);\r\n      if (isColor) {\r\n        output = withAlpha(output);\r\n      }\r\n      if (input >= value) {\r\n        if (i === 2) {\r\n          return output;\r\n        }\r\n        if (isColor) {\r\n          return interpolateColor(\r\n            base,\r\n            value,\r\n            previousInput,\r\n            previousOutput,\r\n            input,\r\n            output,\r\n          );\r\n        }\r\n        return interpolateNumber(\r\n          base,\r\n          value,\r\n          previousInput,\r\n          previousOutput,\r\n          input,\r\n          output,\r\n        );\r\n      }\r\n      previousInput = input;\r\n      previousOutput = output;\r\n    }\r\n    return previousOutput;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {import('./expression.js').CallExpression} expression The call expression.\r\n * @param {import('./expression.js').ParsingContext} context The parsing context.\r\n * @return {ExpressionEvaluator} The evaluator function.\r\n */\r\nfunction compileConvertExpression(expression, context) {\r\n  const op = expression.operator;\r\n  const length = expression.args.length;\r\n\r\n  const args = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    args[i] = compileExpression(expression.args[i], context);\r\n  }\r\n  switch (op) {\r\n    case Ops.ToString: {\r\n      return (context) => {\r\n        const value = args[0](context);\r\n        if (expression.args[0].type === ColorType) {\r\n          return toString(value);\r\n        }\r\n        return value.toString();\r\n      };\r\n    }\r\n    default: {\r\n      throw new Error(`Unsupported convert operator ${op}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {number} base The base.\r\n * @param {number} value The value.\r\n * @param {number} input1 The first input value.\r\n * @param {number} output1 The first output value.\r\n * @param {number} input2 The second input value.\r\n * @param {number} output2 The second output value.\r\n * @return {number} The interpolated value.\r\n */\r\nfunction interpolateNumber(base, value, input1, output1, input2, output2) {\r\n  const delta = input2 - input1;\r\n  if (delta === 0) {\r\n    return output1;\r\n  }\r\n  const along = value - input1;\r\n  const factor =\r\n    base === 1\r\n      ? along / delta\r\n      : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);\r\n  return output1 + factor * (output2 - output1);\r\n}\r\n\r\n/**\r\n * @param {number} base The base.\r\n * @param {number} value The value.\r\n * @param {number} input1 The first input value.\r\n * @param {import('../color.js').Color} rgba1 The first output value.\r\n * @param {number} input2 The second input value.\r\n * @param {import('../color.js').Color} rgba2 The second output value.\r\n * @return {import('../color.js').Color} The interpolated color.\r\n */\r\nfunction interpolateColor(base, value, input1, rgba1, input2, rgba2) {\r\n  const delta = input2 - input1;\r\n  if (delta === 0) {\r\n    return rgba1;\r\n  }\r\n  const lcha1 = rgbaToLcha(rgba1);\r\n  const lcha2 = rgbaToLcha(rgba2);\r\n  let deltaHue = lcha2[2] - lcha1[2];\r\n  if (deltaHue > 180) {\r\n    deltaHue -= 360;\r\n  } else if (deltaHue < -180) {\r\n    deltaHue += 360;\r\n  }\r\n\r\n  const lcha = [\r\n    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),\r\n    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),\r\n    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),\r\n    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3]),\r\n  ];\r\n  return normalize(lchaToRgba(lcha));\r\n}\r\n", "/**\r\n * @module ol/render/canvas/style\r\n */\r\n\r\nimport Circle from '../../style/Circle.js';\r\nimport Fill from '../../style/Fill.js';\r\nimport Icon from '../../style/Icon.js';\r\nimport RegularShape from '../../style/RegularShape.js';\r\nimport Stroke from '../../style/Stroke.js';\r\nimport Style from '../../style/Style.js';\r\nimport Text from '../../style/Text.js';\r\nimport {\r\n  BooleanType,\r\n  ColorType,\r\n  NumberArrayType,\r\n  NumberType,\r\n  StringType,\r\n  computeGeometryType,\r\n  newParsingContext,\r\n} from '../../expr/expression.js';\r\nimport {buildExpression, newEvaluationContext} from '../../expr/cpu.js';\r\nimport {isEmpty} from '../../obj.js';\r\nimport {toSize} from '../../size.js';\r\n\r\n/**\r\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\r\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\r\n * and returns an instance of one of the expression classes.  The compiling step takes the\r\n * expression instance and returns a function that can be evaluated to return a literal value.  The\r\n * evaluator function should do as little allocation and work as possible.\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\r\n */\r\n\r\n/**\r\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\r\n */\r\n\r\n/**\r\n * @param {EvaluationContext} context The evaluation context.\r\n * @return {boolean} Always true.\r\n */\r\nfunction always(context) {\r\n  return true;\r\n}\r\n\r\n/**\r\n * This function adapts a rule evaluator to the existing style function interface.\r\n * After we have deprecated the style function, we can use the compiled rules directly\r\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\r\n *\r\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\r\n * @return {import('../../style/Style.js').StyleFunction} A style function.\r\n */\r\nexport function rulesToStyleFunction(rules) {\r\n  const parsingContext = newParsingContext();\r\n  const evaluator = buildRuleSet(rules, parsingContext);\r\n  const evaluationContext = newEvaluationContext();\r\n  return function (feature, resolution) {\r\n    evaluationContext.properties = feature.getPropertiesInternal();\r\n    evaluationContext.resolution = resolution;\r\n    if (parsingContext.featureId) {\r\n      const id = feature.getId();\r\n      if (id !== undefined) {\r\n        evaluationContext.featureId = id;\r\n      } else {\r\n        evaluationContext.featureId = null;\r\n      }\r\n    }\r\n    if (parsingContext.geometryType) {\r\n      evaluationContext.geometryType = computeGeometryType(\r\n        feature.getGeometry(),\r\n      );\r\n    }\r\n    return evaluator(evaluationContext);\r\n  };\r\n}\r\n\r\n/**\r\n * This function adapts a style evaluator to the existing style function interface.\r\n * After we have deprecated the style function, we can use the compiled rules directly\r\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\r\n *\r\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\r\n * @return {import('../../style/Style.js').StyleFunction} A style function.\r\n */\r\nexport function flatStylesToStyleFunction(flatStyles) {\r\n  const parsingContext = newParsingContext();\r\n  const length = flatStyles.length;\r\n\r\n  /**\r\n   * @type {Array<StyleEvaluator>}\r\n   */\r\n  const evaluators = new Array(length);\r\n  for (let i = 0; i < length; ++i) {\r\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\r\n  }\r\n  const evaluationContext = newEvaluationContext();\r\n\r\n  /**\r\n   * @type {Array<Style>}\r\n   */\r\n  const styles = new Array(length);\r\n\r\n  return function (feature, resolution) {\r\n    evaluationContext.properties = feature.getPropertiesInternal();\r\n    evaluationContext.resolution = resolution;\r\n    if (parsingContext.featureId) {\r\n      const id = feature.getId();\r\n      if (id !== undefined) {\r\n        evaluationContext.featureId = id;\r\n      } else {\r\n        evaluationContext.featureId = null;\r\n      }\r\n    }\r\n    let nonNullCount = 0;\r\n    for (let i = 0; i < length; ++i) {\r\n      const style = evaluators[i](evaluationContext);\r\n      if (style) {\r\n        styles[nonNullCount] = style;\r\n        nonNullCount += 1;\r\n      }\r\n    }\r\n    styles.length = nonNullCount;\r\n    return styles;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\r\n */\r\n\r\n/**\r\n * @typedef {Object} CompiledRule\r\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\r\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\r\n */\r\n\r\n/**\r\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {RuleSetEvaluator} The evaluator function.\r\n */\r\nexport function buildRuleSet(rules, context) {\r\n  const length = rules.length;\r\n\r\n  /**\r\n   * @type {Array<CompiledRule>}\r\n   */\r\n  const compiledRules = new Array(length);\r\n\r\n  for (let i = 0; i < length; ++i) {\r\n    const rule = rules[i];\r\n    const filter =\r\n      'filter' in rule\r\n        ? buildExpression(rule.filter, BooleanType, context)\r\n        : always;\r\n\r\n    /**\r\n     * @type {Array<StyleEvaluator>}\r\n     */\r\n    let styles;\r\n    if (Array.isArray(rule.style)) {\r\n      const styleLength = rule.style.length;\r\n      styles = new Array(styleLength);\r\n      for (let j = 0; j < styleLength; ++j) {\r\n        styles[j] = buildStyle(rule.style[j], context);\r\n      }\r\n    } else {\r\n      styles = [buildStyle(rule.style, context)];\r\n    }\r\n\r\n    compiledRules[i] = {filter, styles};\r\n  }\r\n\r\n  return function (context) {\r\n    /**\r\n     * @type {Array<Style>}\r\n     */\r\n    const styles = [];\r\n\r\n    let someMatched = false;\r\n    for (let i = 0; i < length; ++i) {\r\n      const filterEvaluator = compiledRules[i].filter;\r\n      if (!filterEvaluator(context)) {\r\n        continue;\r\n      }\r\n      if (rules[i].else && someMatched) {\r\n        continue;\r\n      }\r\n      someMatched = true;\r\n      for (const styleEvaluator of compiledRules[i].styles) {\r\n        const style = styleEvaluator(context);\r\n        if (!style) {\r\n          continue;\r\n        }\r\n        styles.push(style);\r\n      }\r\n    }\r\n\r\n    return styles;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\r\n */\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle A flat style literal.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\r\n * this function will be reused between invocations.\r\n */\r\nexport function buildStyle(flatStyle, context) {\r\n  const evaluateFill = buildFill(flatStyle, '', context);\r\n  const evaluateStroke = buildStroke(flatStyle, '', context);\r\n  const evaluateText = buildText(flatStyle, context);\r\n  const evaluateImage = buildImage(flatStyle, context);\r\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\r\n\r\n  if (\r\n    !evaluateFill &&\r\n    !evaluateStroke &&\r\n    !evaluateText &&\r\n    !evaluateImage &&\r\n    !isEmpty(flatStyle)\r\n  ) {\r\n    // assume this is a user error\r\n    // would be nice to check the properties and suggest \"did you mean...\"\r\n    throw new Error(\r\n      'No fill, stroke, point, or text symbolizer properties in style: ' +\r\n        JSON.stringify(flatStyle),\r\n    );\r\n  }\r\n\r\n  const style = new Style();\r\n  return function (context) {\r\n    let empty = true;\r\n    if (evaluateFill) {\r\n      const fill = evaluateFill(context);\r\n      if (fill) {\r\n        empty = false;\r\n      }\r\n      style.setFill(fill);\r\n    }\r\n    if (evaluateStroke) {\r\n      const stroke = evaluateStroke(context);\r\n      if (stroke) {\r\n        empty = false;\r\n      }\r\n      style.setStroke(stroke);\r\n    }\r\n    if (evaluateText) {\r\n      const text = evaluateText(context);\r\n      if (text) {\r\n        empty = false;\r\n      }\r\n      style.setText(text);\r\n    }\r\n    if (evaluateImage) {\r\n      const image = evaluateImage(context);\r\n      if (image) {\r\n        empty = false;\r\n      }\r\n      style.setImage(image);\r\n    }\r\n    if (evaluateZIndex) {\r\n      style.setZIndex(evaluateZIndex(context));\r\n    }\r\n    if (empty) {\r\n      return null;\r\n    }\r\n    return style;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\r\n */\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} prefix The property prefix.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {FillEvaluator?} A function that evaluates to a fill.\r\n */\r\nfunction buildFill(flatStyle, prefix, context) {\r\n  let evaluateColor;\r\n  if (prefix + 'fill-pattern-src' in flatStyle) {\r\n    evaluateColor = patternEvaluator(flatStyle, prefix + 'fill-', context);\r\n  } else {\r\n    evaluateColor = colorLikeEvaluator(\r\n      flatStyle,\r\n      prefix + 'fill-color',\r\n      context,\r\n    );\r\n  }\r\n  if (!evaluateColor) {\r\n    return null;\r\n  }\r\n\r\n  const fill = new Fill();\r\n  return function (context) {\r\n    const color = evaluateColor(context);\r\n    if (color === 'none') {\r\n      return null;\r\n    }\r\n    fill.setColor(color);\r\n    return fill;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\r\n */\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} prefix The property prefix.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\r\n */\r\nfunction buildStroke(flatStyle, prefix, context) {\r\n  const evaluateWidth = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-width',\r\n    context,\r\n  );\r\n\r\n  const evaluateColor = colorLikeEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-color',\r\n    context,\r\n  );\r\n\r\n  if (!evaluateWidth && !evaluateColor) {\r\n    return null;\r\n  }\r\n\r\n  const evaluateLineCap = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-line-cap',\r\n    context,\r\n  );\r\n\r\n  const evaluateLineJoin = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-line-join',\r\n    context,\r\n  );\r\n\r\n  const evaluateLineDash = numberArrayEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-line-dash',\r\n    context,\r\n  );\r\n\r\n  const evaluateLineDashOffset = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-line-dash-offset',\r\n    context,\r\n  );\r\n\r\n  const evaluateMiterLimit = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'stroke-miter-limit',\r\n    context,\r\n  );\r\n\r\n  const stroke = new Stroke();\r\n  return function (context) {\r\n    if (evaluateColor) {\r\n      const color = evaluateColor(context);\r\n      if (color === 'none') {\r\n        return null;\r\n      }\r\n      stroke.setColor(color);\r\n    }\r\n\r\n    if (evaluateWidth) {\r\n      stroke.setWidth(evaluateWidth(context));\r\n    }\r\n\r\n    if (evaluateLineCap) {\r\n      const lineCap = evaluateLineCap(context);\r\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\r\n        throw new Error('Expected butt, round, or square line cap');\r\n      }\r\n      stroke.setLineCap(lineCap);\r\n    }\r\n\r\n    if (evaluateLineJoin) {\r\n      const lineJoin = evaluateLineJoin(context);\r\n      if (\r\n        lineJoin !== 'bevel' &&\r\n        lineJoin !== 'round' &&\r\n        lineJoin !== 'miter'\r\n      ) {\r\n        throw new Error('Expected bevel, round, or miter line join');\r\n      }\r\n      stroke.setLineJoin(lineJoin);\r\n    }\r\n\r\n    if (evaluateLineDash) {\r\n      stroke.setLineDash(evaluateLineDash(context));\r\n    }\r\n\r\n    if (evaluateLineDashOffset) {\r\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\r\n    }\r\n\r\n    if (evaluateMiterLimit) {\r\n      stroke.setMiterLimit(evaluateMiterLimit(context));\r\n    }\r\n\r\n    return stroke;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):Text} TextEvaluator\r\n */\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\r\n */\r\nfunction buildText(flatStyle, context) {\r\n  const prefix = 'text-';\r\n\r\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\r\n  // work with our expression syntax where arrays of strings are interpreted as\r\n  // call expressions.  To support rich text, we could add a 'strings' operator\r\n  // where all the following arguments would be string values.\r\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\r\n  if (!evaluateValue) {\r\n    return null;\r\n  }\r\n\r\n  const evaluateFill = buildFill(flatStyle, prefix, context);\r\n\r\n  const evaluateBackgroundFill = buildFill(\r\n    flatStyle,\r\n    prefix + 'background-',\r\n    context,\r\n  );\r\n\r\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\r\n\r\n  const evaluateBackgroundStroke = buildStroke(\r\n    flatStyle,\r\n    prefix + 'background-',\r\n    context,\r\n  );\r\n\r\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\r\n\r\n  const evaluateMaxAngle = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'max-angle',\r\n    context,\r\n  );\r\n\r\n  const evaluateOffsetX = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'offset-x',\r\n    context,\r\n  );\r\n\r\n  const evaluateOffsetY = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'offset-y',\r\n    context,\r\n  );\r\n\r\n  const evaluateOverflow = booleanEvaluator(\r\n    flatStyle,\r\n    prefix + 'overflow',\r\n    context,\r\n  );\r\n\r\n  const evaluatePlacement = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'placement',\r\n    context,\r\n  );\r\n\r\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\r\n\r\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\r\n\r\n  const evaluateRotateWithView = booleanEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotate-with-view',\r\n    context,\r\n  );\r\n\r\n  const evaluateRotation = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotation',\r\n    context,\r\n  );\r\n\r\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\r\n\r\n  const evaluateJustify = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'justify',\r\n    context,\r\n  );\r\n\r\n  const evaluateBaseline = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'baseline',\r\n    context,\r\n  );\r\n\r\n  const evaluatePadding = numberArrayEvaluator(\r\n    flatStyle,\r\n    prefix + 'padding',\r\n    context,\r\n  );\r\n\r\n  // The following properties are not currently settable\r\n  const declutterMode = optionalDeclutterMode(\r\n    flatStyle,\r\n    prefix + 'declutter-mode',\r\n  );\r\n\r\n  const text = new Text({declutterMode});\r\n\r\n  return function (context) {\r\n    text.setText(evaluateValue(context));\r\n\r\n    if (evaluateFill) {\r\n      text.setFill(evaluateFill(context));\r\n    }\r\n\r\n    if (evaluateBackgroundFill) {\r\n      text.setBackgroundFill(evaluateBackgroundFill(context));\r\n    }\r\n\r\n    if (evaluateStroke) {\r\n      text.setStroke(evaluateStroke(context));\r\n    }\r\n\r\n    if (evaluateBackgroundStroke) {\r\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\r\n    }\r\n\r\n    if (evaluateFont) {\r\n      text.setFont(evaluateFont(context));\r\n    }\r\n\r\n    if (evaluateMaxAngle) {\r\n      text.setMaxAngle(evaluateMaxAngle(context));\r\n    }\r\n\r\n    if (evaluateOffsetX) {\r\n      text.setOffsetX(evaluateOffsetX(context));\r\n    }\r\n\r\n    if (evaluateOffsetY) {\r\n      text.setOffsetY(evaluateOffsetY(context));\r\n    }\r\n\r\n    if (evaluateOverflow) {\r\n      text.setOverflow(evaluateOverflow(context));\r\n    }\r\n\r\n    if (evaluatePlacement) {\r\n      const placement = evaluatePlacement(context);\r\n      if (placement !== 'point' && placement !== 'line') {\r\n        throw new Error('Expected point or line for text-placement');\r\n      }\r\n      text.setPlacement(placement);\r\n    }\r\n\r\n    if (evaluateRepeat) {\r\n      text.setRepeat(evaluateRepeat(context));\r\n    }\r\n\r\n    if (evaluateScale) {\r\n      text.setScale(evaluateScale(context));\r\n    }\r\n\r\n    if (evaluateRotateWithView) {\r\n      text.setRotateWithView(evaluateRotateWithView(context));\r\n    }\r\n\r\n    if (evaluateRotation) {\r\n      text.setRotation(evaluateRotation(context));\r\n    }\r\n\r\n    if (evaluateAlign) {\r\n      const textAlign = evaluateAlign(context);\r\n      if (\r\n        textAlign !== 'left' &&\r\n        textAlign !== 'center' &&\r\n        textAlign !== 'right' &&\r\n        textAlign !== 'end' &&\r\n        textAlign !== 'start'\r\n      ) {\r\n        throw new Error(\r\n          'Expected left, right, center, start, or end for text-align',\r\n        );\r\n      }\r\n      text.setTextAlign(textAlign);\r\n    }\r\n\r\n    if (evaluateJustify) {\r\n      const justify = evaluateJustify(context);\r\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\r\n        throw new Error('Expected left, right, or center for text-justify');\r\n      }\r\n      text.setJustify(justify);\r\n    }\r\n\r\n    if (evaluateBaseline) {\r\n      const textBaseline = evaluateBaseline(context);\r\n      if (\r\n        textBaseline !== 'bottom' &&\r\n        textBaseline !== 'top' &&\r\n        textBaseline !== 'middle' &&\r\n        textBaseline !== 'alphabetic' &&\r\n        textBaseline !== 'hanging'\r\n      ) {\r\n        throw new Error(\r\n          'Expected bottom, top, middle, alphabetic, or hanging for text-baseline',\r\n        );\r\n      }\r\n      text.setTextBaseline(textBaseline);\r\n    }\r\n\r\n    if (evaluatePadding) {\r\n      text.setPadding(evaluatePadding(context));\r\n    }\r\n\r\n    return text;\r\n  };\r\n}\r\n\r\n/**\r\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\r\n */\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\r\n */\r\nfunction buildImage(flatStyle, context) {\r\n  if ('icon-src' in flatStyle) {\r\n    return buildIcon(flatStyle, context);\r\n  }\r\n\r\n  if ('shape-points' in flatStyle) {\r\n    return buildShape(flatStyle, context);\r\n  }\r\n\r\n  if ('circle-radius' in flatStyle) {\r\n    return buildCircle(flatStyle, context);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\r\n */\r\nfunction buildIcon(flatStyle, context) {\r\n  const prefix = 'icon-';\r\n\r\n  // required property\r\n  const srcName = prefix + 'src';\r\n  const src = requireString(flatStyle[srcName], srcName);\r\n\r\n  // settable properties\r\n  const evaluateAnchor = coordinateEvaluator(\r\n    flatStyle,\r\n    prefix + 'anchor',\r\n    context,\r\n  );\r\n\r\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\r\n\r\n  const evaluateOpacity = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'opacity',\r\n    context,\r\n  );\r\n\r\n  const evaluateDisplacement = coordinateEvaluator(\r\n    flatStyle,\r\n    prefix + 'displacement',\r\n    context,\r\n  );\r\n\r\n  const evaluateRotation = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotation',\r\n    context,\r\n  );\r\n\r\n  const evaluateRotateWithView = booleanEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotate-with-view',\r\n    context,\r\n  );\r\n\r\n  // the remaining symbolizer properties are not currently settable\r\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\r\n  const anchorXUnits = optionalIconAnchorUnits(\r\n    flatStyle,\r\n    prefix + 'anchor-x-units',\r\n  );\r\n  const anchorYUnits = optionalIconAnchorUnits(\r\n    flatStyle,\r\n    prefix + 'anchor-y-units',\r\n  );\r\n  const color = optionalColorLike(flatStyle, prefix + 'color');\r\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\r\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\r\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\r\n  const width = optionalNumber(flatStyle, prefix + 'width');\r\n  const height = optionalNumber(flatStyle, prefix + 'height');\r\n  const size = optionalSize(flatStyle, prefix + 'size');\r\n  const declutterMode = optionalDeclutterMode(\r\n    flatStyle,\r\n    prefix + 'declutter-mode',\r\n  );\r\n\r\n  const icon = new Icon({\r\n    src,\r\n    anchorOrigin,\r\n    anchorXUnits,\r\n    anchorYUnits,\r\n    color,\r\n    crossOrigin,\r\n    offset,\r\n    offsetOrigin,\r\n    height,\r\n    width,\r\n    size,\r\n    declutterMode,\r\n  });\r\n\r\n  return function (context) {\r\n    if (evaluateOpacity) {\r\n      icon.setOpacity(evaluateOpacity(context));\r\n    }\r\n\r\n    if (evaluateDisplacement) {\r\n      icon.setDisplacement(evaluateDisplacement(context));\r\n    }\r\n\r\n    if (evaluateRotation) {\r\n      icon.setRotation(evaluateRotation(context));\r\n    }\r\n\r\n    if (evaluateRotateWithView) {\r\n      icon.setRotateWithView(evaluateRotateWithView(context));\r\n    }\r\n\r\n    if (evaluateScale) {\r\n      icon.setScale(evaluateScale(context));\r\n    }\r\n\r\n    if (evaluateAnchor) {\r\n      icon.setAnchor(evaluateAnchor(context));\r\n    }\r\n    return icon;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\r\n */\r\nfunction buildShape(flatStyle, context) {\r\n  const prefix = 'shape-';\r\n\r\n  // required property\r\n  const pointsName = prefix + 'points';\r\n  const radiusName = prefix + 'radius';\r\n  const points = requireNumber(flatStyle[pointsName], pointsName);\r\n  const radius = requireNumber(flatStyle[radiusName], radiusName);\r\n\r\n  // settable properties\r\n  const evaluateFill = buildFill(flatStyle, prefix, context);\r\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\r\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\r\n  const evaluateDisplacement = coordinateEvaluator(\r\n    flatStyle,\r\n    prefix + 'displacement',\r\n    context,\r\n  );\r\n  const evaluateRotation = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotation',\r\n    context,\r\n  );\r\n  const evaluateRotateWithView = booleanEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotate-with-view',\r\n    context,\r\n  );\r\n\r\n  // the remaining properties are not currently settable\r\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\r\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\r\n  const declutterMode = optionalDeclutterMode(\r\n    flatStyle,\r\n    prefix + 'declutter-mode',\r\n  );\r\n\r\n  const shape = new RegularShape({\r\n    points,\r\n    radius,\r\n    radius2,\r\n    angle,\r\n    declutterMode,\r\n  });\r\n\r\n  return function (context) {\r\n    if (evaluateFill) {\r\n      shape.setFill(evaluateFill(context));\r\n    }\r\n    if (evaluateStroke) {\r\n      shape.setStroke(evaluateStroke(context));\r\n    }\r\n    if (evaluateDisplacement) {\r\n      shape.setDisplacement(evaluateDisplacement(context));\r\n    }\r\n    if (evaluateRotation) {\r\n      shape.setRotation(evaluateRotation(context));\r\n    }\r\n    if (evaluateRotateWithView) {\r\n      shape.setRotateWithView(evaluateRotateWithView(context));\r\n    }\r\n    if (evaluateScale) {\r\n      shape.setScale(evaluateScale(context));\r\n    }\r\n\r\n    return shape;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\r\n */\r\nfunction buildCircle(flatStyle, context) {\r\n  const prefix = 'circle-';\r\n\r\n  // settable properties\r\n  const evaluateFill = buildFill(flatStyle, prefix, context);\r\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\r\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\r\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\r\n  const evaluateDisplacement = coordinateEvaluator(\r\n    flatStyle,\r\n    prefix + 'displacement',\r\n    context,\r\n  );\r\n  const evaluateRotation = numberEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotation',\r\n    context,\r\n  );\r\n  const evaluateRotateWithView = booleanEvaluator(\r\n    flatStyle,\r\n    prefix + 'rotate-with-view',\r\n    context,\r\n  );\r\n\r\n  // the remaining properties are not currently settable\r\n  const declutterMode = optionalDeclutterMode(\r\n    flatStyle,\r\n    prefix + 'declutter-mode',\r\n  );\r\n\r\n  const circle = new Circle({\r\n    radius: 5, // this is arbitrary, but required - the evaluated radius is used below\r\n    declutterMode,\r\n  });\r\n\r\n  return function (context) {\r\n    if (evaluateRadius) {\r\n      circle.setRadius(evaluateRadius(context));\r\n    }\r\n    if (evaluateFill) {\r\n      circle.setFill(evaluateFill(context));\r\n    }\r\n    if (evaluateStroke) {\r\n      circle.setStroke(evaluateStroke(context));\r\n    }\r\n    if (evaluateDisplacement) {\r\n      circle.setDisplacement(evaluateDisplacement(context));\r\n    }\r\n    if (evaluateRotation) {\r\n      circle.setRotation(evaluateRotation(context));\r\n    }\r\n    if (evaluateRotateWithView) {\r\n      circle.setRotateWithView(evaluateRotateWithView(context));\r\n    }\r\n    if (evaluateScale) {\r\n      circle.setScale(evaluateScale(context));\r\n    }\r\n\r\n    return circle;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\r\n */\r\nfunction numberEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return undefined;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\r\n  return function (context) {\r\n    return requireNumber(evaluator(context), name);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\r\n */\r\nfunction stringEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\r\n  return function (context) {\r\n    return requireString(evaluator(context), name);\r\n  };\r\n}\r\n\r\nfunction patternEvaluator(flatStyle, prefix, context) {\r\n  const srcEvaluator = stringEvaluator(\r\n    flatStyle,\r\n    prefix + 'pattern-src',\r\n    context,\r\n  );\r\n  const offsetEvaluator = sizeEvaluator(\r\n    flatStyle,\r\n    prefix + 'pattern-offset',\r\n    context,\r\n  );\r\n  const patternSizeEvaluator = sizeEvaluator(\r\n    flatStyle,\r\n    prefix + 'pattern-size',\r\n    context,\r\n  );\r\n  const colorEvaluator = colorLikeEvaluator(\r\n    flatStyle,\r\n    prefix + 'color',\r\n    context,\r\n  );\r\n  return function (context) {\r\n    return {\r\n      src: srcEvaluator(context),\r\n      offset: offsetEvaluator && offsetEvaluator(context),\r\n      size: patternSizeEvaluator && patternSizeEvaluator(context),\r\n      color: colorEvaluator && colorEvaluator(context),\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\r\n */\r\nfunction booleanEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\r\n  return function (context) {\r\n    const value = evaluator(context);\r\n    if (typeof value !== 'boolean') {\r\n      throw new Error(`Expected a boolean for ${name}`);\r\n    }\r\n    return value;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\r\n */\r\nfunction colorLikeEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(\r\n    flatStyle[name],\r\n    ColorType | StringType,\r\n    context,\r\n  );\r\n  return function (context) {\r\n    return requireColorLike(evaluator(context), name);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\r\n */\r\nfunction numberArrayEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\r\n  return function (context) {\r\n    return requireNumberArray(evaluator(context), name);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\r\n */\r\nfunction coordinateEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\r\n  return function (context) {\r\n    const array = requireNumberArray(evaluator(context), name);\r\n    if (array.length !== 2) {\r\n      throw new Error(`Expected two numbers for ${name}`);\r\n    }\r\n    return array;\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').SizeEvaluator?} The expression evaluator.\r\n */\r\nfunction sizeEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\r\n  return function (context) {\r\n    return requireSize(evaluator(context), name);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} name The property name.\r\n * @param {ParsingContext} context The parsing context.\r\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\r\n */\r\nfunction sizeLikeEvaluator(flatStyle, name, context) {\r\n  if (!(name in flatStyle)) {\r\n    return null;\r\n  }\r\n  const evaluator = buildExpression(\r\n    flatStyle[name],\r\n    NumberArrayType | NumberType,\r\n    context,\r\n  );\r\n  return function (context) {\r\n    return requireSizeLike(evaluator(context), name);\r\n  };\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {number|undefined} A number or undefined.\r\n */\r\nfunction optionalNumber(flatStyle, property) {\r\n  const value = flatStyle[property];\r\n  if (value === undefined) {\r\n    return undefined;\r\n  }\r\n  if (typeof value !== 'number') {\r\n    throw new Error(`Expected a number for ${property}`);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\r\n */\r\nfunction optionalSize(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  if (typeof encoded === 'number') {\r\n    return toSize(encoded);\r\n  }\r\n  if (!Array.isArray(encoded)) {\r\n    throw new Error(`Expected a number or size array for ${property}`);\r\n  }\r\n  if (\r\n    encoded.length !== 2 ||\r\n    typeof encoded[0] !== 'number' ||\r\n    typeof encoded[1] !== 'number'\r\n  ) {\r\n    throw new Error(`Expected a number or size array for ${property}`);\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {string|undefined} A string or undefined.\r\n */\r\nfunction optionalString(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  if (typeof encoded !== 'string') {\r\n    throw new Error(`Expected a string for ${property}`);\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\r\n */\r\nfunction optionalIconOrigin(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  if (\r\n    encoded !== 'bottom-left' &&\r\n    encoded !== 'bottom-right' &&\r\n    encoded !== 'top-left' &&\r\n    encoded !== 'top-right'\r\n  ) {\r\n    throw new Error(\r\n      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`,\r\n    );\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\r\n */\r\nfunction optionalIconAnchorUnits(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\r\n    throw new Error(`Expected pixels or fraction for ${property}`);\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {Array<number>|undefined} An array of numbers or undefined.\r\n */\r\nfunction optionalNumberArray(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  return requireNumberArray(encoded, property);\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {import('../../style/Style.js').DeclutterMode} Icon declutter mode.\r\n */\r\nfunction optionalDeclutterMode(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  if (typeof encoded !== 'string') {\r\n    throw new Error(`Expected a string for ${property}`);\r\n  }\r\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\r\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\r\n  }\r\n  return encoded;\r\n}\r\n\r\n/**\r\n * @param {FlatStyle} flatStyle The flat style.\r\n * @param {string} property The symbolizer property.\r\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\r\n */\r\nfunction optionalColorLike(flatStyle, property) {\r\n  const encoded = flatStyle[property];\r\n  if (encoded === undefined) {\r\n    return undefined;\r\n  }\r\n  return requireColorLike(encoded, property);\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {Array<number>} An array of numbers.\r\n */\r\nfunction requireNumberArray(value, property) {\r\n  if (!Array.isArray(value)) {\r\n    throw new Error(`Expected an array for ${property}`);\r\n  }\r\n  const length = value.length;\r\n  for (let i = 0; i < length; ++i) {\r\n    if (typeof value[i] !== 'number') {\r\n      throw new Error(`Expected an array of numbers for ${property}`);\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {string} A string.\r\n */\r\nfunction requireString(value, property) {\r\n  if (typeof value !== 'string') {\r\n    throw new Error(`Expected a string for ${property}`);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {number} A number.\r\n */\r\nfunction requireNumber(value, property) {\r\n  if (typeof value !== 'number') {\r\n    throw new Error(`Expected a number for ${property}`);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {Array<number>|string} A color.\r\n */\r\nfunction requireColorLike(value, property) {\r\n  if (typeof value === 'string') {\r\n    return value;\r\n  }\r\n  const array = requireNumberArray(value, property);\r\n  const length = array.length;\r\n  if (length < 3 || length > 4) {\r\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\r\n  }\r\n  return array;\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {Array<number>} A number or an array of two numbers.\r\n */\r\nfunction requireSize(value, property) {\r\n  const size = requireNumberArray(value, property);\r\n  if (size.length !== 2) {\r\n    throw new Error(`Expected an array of two numbers for ${property}`);\r\n  }\r\n  return size;\r\n}\r\n\r\n/**\r\n * @param {any} value The value.\r\n * @param {string} property The property.\r\n * @return {number|Array<number>} A number or an array of two numbers.\r\n */\r\nfunction requireSizeLike(value, property) {\r\n  if (typeof value === 'number') {\r\n    return value;\r\n  }\r\n  return requireSize(value, property);\r\n}\r\n", "/**\r\n * @module ol/layer/BaseVector\r\n */\r\nimport Layer from './Layer.js';\r\nimport RBush from 'rbush';\r\nimport Style, {\r\n  createDefaultStyle,\r\n  toFunction as toStyleFunction,\r\n} from '../style/Style.js';\r\nimport {\r\n  flatStylesToStyleFunction,\r\n  rulesToStyleFunction,\r\n} from '../render/canvas/style.js';\r\n\r\n/**\r\n * @template {import(\"../source/Vector.js\").default<import('../Feature').FeatureLike>|import(\"../source/VectorTile.js\").default<import('../Feature').FeatureLike>} VectorSourceType\r\n * @typedef {Object} Options\r\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\r\n * @property {number} [opacity=1] Opacity (0, 1).\r\n * @property {boolean} [visible=true] Visibility.\r\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\r\n * rendered outside of this extent.\r\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\r\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\r\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\r\n * method was used.\r\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\r\n * visible.\r\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\r\n * be visible.\r\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\r\n * visible.\r\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\r\n * be visible.\r\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\r\n * features before rendering. By default features are drawn in the order that they are created. Use\r\n * `null` to avoid the sort, but get an undefined draw order.\r\n * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\r\n * renderer when getting features from the vector source for the rendering or hit-detection.\r\n * Recommended value: the size of the largest symbol, line width or label.\r\n * @property {VectorSourceType} [source] Source.\r\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\r\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\r\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\r\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\r\n * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable\r\n * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the\r\n * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the\r\n * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct\r\n * layers or groups of layers separately, use different truthy values for `declutter`.\r\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style. When set to `null`, only\r\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\r\n * which will be used if this is not set.\r\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\r\n * will be rendered.\r\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will\r\n * be recreated during animations. This means that no vectors will be shown clipped, but the\r\n * setting will have a performance impact for large amounts of vector data. When set to `false`,\r\n * batches will be recreated when no animation is active.\r\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will\r\n * be recreated during interactions. See also `updateWhileAnimating`.\r\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\r\n */\r\n\r\n/**\r\n * @enum {string}\r\n * @private\r\n */\r\nconst Property = {\r\n  RENDER_ORDER: 'renderOrder',\r\n};\r\n\r\n/**\r\n * @classdesc\r\n * Vector data that is rendered client-side.\r\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\r\n * property on the layer object; for example, setting `title: 'My Title'` in the\r\n * options means that `title` is observable, and has get/set accessors.\r\n *\r\n * @template {import(\"../source/Vector.js\").default<import('../Feature').FeatureLike>|import(\"../source/VectorTile.js\").default<import('../Feature').FeatureLike>} VectorSourceType\r\n * @template {import(\"../renderer/canvas/VectorLayer.js\").default|import(\"../renderer/canvas/VectorTileLayer.js\").default|import(\"../renderer/canvas/VectorImageLayer.js\").default|import(\"../renderer/webgl/PointsLayer.js\").default} RendererType\r\n * @extends {Layer<VectorSourceType, RendererType>}\r\n * @api\r\n */\r\nclass BaseVectorLayer extends Layer {\r\n  /**\r\n   * @param {Options<VectorSourceType>} [options] Options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : {};\r\n\r\n    const baseOptions = Object.assign({}, options);\r\n\r\n    delete baseOptions.style;\r\n    delete baseOptions.renderBuffer;\r\n    delete baseOptions.updateWhileAnimating;\r\n    delete baseOptions.updateWhileInteracting;\r\n    super(baseOptions);\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.declutter_ = options.declutter ? String(options.declutter) : undefined;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.renderBuffer_ =\r\n      options.renderBuffer !== undefined ? options.renderBuffer : 100;\r\n\r\n    /**\r\n     * User provided style.\r\n     * @type {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike}\r\n     * @private\r\n     */\r\n    this.style_ = null;\r\n\r\n    /**\r\n     * Style function for use within the library.\r\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\r\n     * @private\r\n     */\r\n    this.styleFunction_ = undefined;\r\n\r\n    this.setStyle(options.style);\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.updateWhileAnimating_ =\r\n      options.updateWhileAnimating !== undefined\r\n        ? options.updateWhileAnimating\r\n        : false;\r\n\r\n    /**\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this.updateWhileInteracting_ =\r\n      options.updateWhileInteracting !== undefined\r\n        ? options.updateWhileInteracting\r\n        : false;\r\n  }\r\n\r\n  /**\r\n   * @return {string} Declutter group.\r\n   */\r\n  getDeclutter() {\r\n    return this.declutter_;\r\n  }\r\n\r\n  /**\r\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\r\n   * that resolves with an array of features. The array will either contain the topmost feature\r\n   * when a hit was detected, or it will be empty.\r\n   *\r\n   * The hit detection algorithm used for this method is optimized for performance, but is less\r\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\r\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\r\n   * image.\r\n   *\r\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\r\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\r\n   * @api\r\n   */\r\n  getFeatures(pixel) {\r\n    return super.getFeatures(pixel);\r\n  }\r\n\r\n  /**\r\n   * @return {number|undefined} Render buffer.\r\n   */\r\n  getRenderBuffer() {\r\n    return this.renderBuffer_;\r\n  }\r\n\r\n  /**\r\n   * @return {function(import(\"../Feature.js\").default, import(\"../Feature.js\").default): number|null|undefined} Render\r\n   *     order.\r\n   */\r\n  getRenderOrder() {\r\n    return /** @type {import(\"../render.js\").OrderFunction|null|undefined} */ (\r\n      this.get(Property.RENDER_ORDER)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the style for features.  This returns whatever was passed to the `style`\r\n   * option at construction or to the `setStyle` method.\r\n   * @return {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null|undefined} Layer style.\r\n   * @api\r\n   */\r\n  getStyle() {\r\n    return this.style_;\r\n  }\r\n\r\n  /**\r\n   * Get the style function.\r\n   * @return {import(\"../style/Style.js\").StyleFunction|undefined} Layer style function.\r\n   * @api\r\n   */\r\n  getStyleFunction() {\r\n    return this.styleFunction_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Whether the rendered layer should be updated while\r\n   *     animating.\r\n   */\r\n  getUpdateWhileAnimating() {\r\n    return this.updateWhileAnimating_;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} Whether the rendered layer should be updated while\r\n   *     interacting.\r\n   */\r\n  getUpdateWhileInteracting() {\r\n    return this.updateWhileInteracting_;\r\n  }\r\n\r\n  /**\r\n   * Render declutter items for this layer\r\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\r\n   * @param {import(\"../layer/Layer.js\").State} layerState Layer state.\r\n   */\r\n  renderDeclutter(frameState, layerState) {\r\n    const declutterGroup = this.getDeclutter();\r\n    if (declutterGroup in frameState.declutter === false) {\r\n      frameState.declutter[declutterGroup] = new RBush(9);\r\n    }\r\n    this.getRenderer().renderDeclutter(frameState, layerState);\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../render.js\").OrderFunction|null|undefined} renderOrder\r\n   *     Render order.\r\n   */\r\n  setRenderOrder(renderOrder) {\r\n    this.set(Property.RENDER_ORDER, renderOrder);\r\n  }\r\n\r\n  /**\r\n   * Set the style for features.  This can be a single style object, an array\r\n   * of styles, or a function that takes a feature and resolution and returns\r\n   * an array of styles. If set to `null`, the layer has no style (a `null` style),\r\n   * so only features that have their own styles will be rendered in the layer. Call\r\n   * `setStyle()` without arguments to reset to the default style. See\r\n   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.\r\n   *\r\n   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object\r\n   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):\r\n   * ```js\r\n   * vectorLayer.setStyle({\r\n   *   \"fill-color\": \"yellow\",\r\n   *   \"stroke-color\": \"black\",\r\n   *   \"stroke-width\": 4\r\n   * })\r\n   * ```\r\n   *\r\n   * @param {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style.\r\n   * @api\r\n   */\r\n  setStyle(style) {\r\n    this.style_ = style === undefined ? createDefaultStyle : style;\r\n    const styleLike = toStyleLike(style);\r\n    this.styleFunction_ =\r\n      style === null ? undefined : toStyleFunction(styleLike);\r\n    this.changed();\r\n  }\r\n}\r\n\r\n/**\r\n * Coerce the allowed style types into a shorter list of types.  Flat styles, arrays of flat\r\n * styles, and arrays of rules are converted into style functions.\r\n *\r\n * @param {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style.\r\n * @return {import(\"../style/Style.js\").StyleLike|null} The style.\r\n */\r\nfunction toStyleLike(style) {\r\n  if (style === undefined) {\r\n    return createDefaultStyle;\r\n  }\r\n  if (!style) {\r\n    return null;\r\n  }\r\n  if (typeof style === 'function') {\r\n    return style;\r\n  }\r\n  if (style instanceof Style) {\r\n    return style;\r\n  }\r\n  if (!Array.isArray(style)) {\r\n    return flatStylesToStyleFunction([style]);\r\n  }\r\n  if (style.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  const length = style.length;\r\n  const first = style[0];\r\n\r\n  if (first instanceof Style) {\r\n    /**\r\n     * @type {Array<Style>}\r\n     */\r\n    const styles = new Array(length);\r\n    for (let i = 0; i < length; ++i) {\r\n      const candidate = style[i];\r\n      if (!(candidate instanceof Style)) {\r\n        throw new Error('Expected a list of style instances');\r\n      }\r\n      styles[i] = candidate;\r\n    }\r\n    return styles;\r\n  }\r\n\r\n  if ('style' in first) {\r\n    /**\r\n     * @type Array<import(\"../style/flat.js\").Rule>\r\n     */\r\n    const rules = new Array(length);\r\n    for (let i = 0; i < length; ++i) {\r\n      const candidate = style[i];\r\n      if (!('style' in candidate)) {\r\n        throw new Error('Expected a list of rules with a style property');\r\n      }\r\n      rules[i] = candidate;\r\n    }\r\n    return rulesToStyleFunction(rules);\r\n  }\r\n\r\n  const flatStyles =\r\n    /** @type {Array<import(\"../style/flat.js\").FlatStyle>} */ (style);\r\n  return flatStylesToStyleFunction(flatStyles);\r\n}\r\n\r\nexport default BaseVectorLayer;\r\n"],
  "mappings": "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",
  "names": ["type", "context", "context"]
}
