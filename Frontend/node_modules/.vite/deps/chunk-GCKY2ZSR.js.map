{
  "version": 3,
  "sources": ["../../ol/proj/Units.js", "../../ol/proj/Projection.js", "../../ol/proj/epsg3857.js", "../../ol/proj/epsg4326.js", "../../ol/proj/projections.js", "../../ol/proj/transforms.js", "../../ol/extent/Relationship.js", "../../ol/extent.js", "../../ol/string.js", "../../ol/coordinate.js", "../../ol/sphere.js", "../../ol/console.js", "../../ol/proj.js"],
  "sourcesContent": ["/**\r\n * @module ol/proj/Units\r\n */\r\n\r\n/**\r\n * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units\r\n * Projection units.\r\n */\r\n\r\n/**\r\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\r\n * @type {Object<number, Units>}\r\n */\r\nconst unitByCode = {\r\n  '9001': 'm',\r\n  '9002': 'ft',\r\n  '9003': 'us-ft',\r\n  '9101': 'radians',\r\n  '9102': 'degrees',\r\n};\r\n\r\n/**\r\n * @param {number} code Unit code.\r\n * @return {Units} Units.\r\n */\r\nexport function fromCode(code) {\r\n  return unitByCode[code];\r\n}\r\n\r\n/**\r\n * @typedef {Object} MetersPerUnitLookup\r\n * @property {number} radians Radians\r\n * @property {number} degrees Degrees\r\n * @property {number} ft  Feet\r\n * @property {number} m Meters\r\n * @property {number} us-ft US feet\r\n */\r\n\r\n/**\r\n * Meters per unit lookup table.\r\n * @const\r\n * @type {MetersPerUnitLookup}\r\n * @api\r\n */\r\nexport const METERS_PER_UNIT = {\r\n  // use the radius of the Normal sphere\r\n  'radians': 6370997 / (2 * Math.PI),\r\n  'degrees': (2 * Math.PI * 6370997) / 360,\r\n  'ft': 0.3048,\r\n  'm': 1,\r\n  'us-ft': 1200 / 3937,\r\n};\r\n", "/**\r\n * @module ol/proj/Projection\r\n */\r\nimport {METERS_PER_UNIT} from './Units.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\r\n * @property {import(\"./Units.js\").Units} [units] Units. Required unless a\r\n * proj4 projection is defined for `code`.\r\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\r\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\r\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\r\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\r\n * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}\r\n * lookup table.\r\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\r\n * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\r\n * Function to determine resolution at a point. The function is called with a\r\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns\r\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\r\n * the default {@link module:ol/proj.getPointResolution} function will be used.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Projection definition class. One of these is created for each projection\r\n * supported in the application and stored in the {@link module:ol/proj} namespace.\r\n * You can use these in applications, but this is not required, as API params\r\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\r\n * code will suffice.\r\n *\r\n * You can use {@link module:ol/proj.get} to retrieve the object for a particular\r\n * projection.\r\n *\r\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\r\n * with the following aliases:\r\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\r\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\r\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\r\n *     urn:x-ogc:def:crs:EPSG:4326\r\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\r\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\r\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\r\n *\r\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\r\n * be added using `proj4.defs()`. After all required projection definitions are\r\n * added, call the {@link module:ol/proj/proj4.register} function.\r\n *\r\n * @api\r\n */\r\nclass Projection {\r\n  /**\r\n   * @param {Options} options Projection options.\r\n   */\r\n  constructor(options) {\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.code_ = options.code;\r\n\r\n    /**\r\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\r\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\r\n     * tile.\r\n     * @private\r\n     * @type {import(\"./Units.js\").Units}\r\n     */\r\n    this.units_ = /** @type {import(\"./Units.js\").Units} */ (options.units);\r\n\r\n    /**\r\n     * Validity extent of the projection in projected coordinates. For projections\r\n     * with `TILE_PIXELS` units, this is the extent of the tile in\r\n     * tile pixel space.\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.extent_ = options.extent !== undefined ? options.extent : null;\r\n\r\n    /**\r\n     * Extent of the world in EPSG:4326. For projections with\r\n     * `TILE_PIXELS` units, this is the extent of the tile in\r\n     * projected coordinate space.\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.worldExtent_ =\r\n      options.worldExtent !== undefined ? options.worldExtent : null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     */\r\n    this.axisOrientation_ =\r\n      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.global_ = options.global !== undefined ? options.global : false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.canWrapX_ = !!(this.global_ && this.extent_);\r\n\r\n    /**\r\n     * @private\r\n     * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\r\n     */\r\n    this.getPointResolutionFunc_ = options.getPointResolution;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\r\n     */\r\n    this.defaultTileGrid_ = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {number|undefined}\r\n     */\r\n    this.metersPerUnit_ = options.metersPerUnit;\r\n  }\r\n\r\n  /**\r\n   * @return {boolean} The projection is suitable for wrapping the x-axis\r\n   */\r\n  canWrapX() {\r\n    return this.canWrapX_;\r\n  }\r\n\r\n  /**\r\n   * Get the code for this projection, e.g. 'EPSG:4326'.\r\n   * @return {string} Code.\r\n   * @api\r\n   */\r\n  getCode() {\r\n    return this.code_;\r\n  }\r\n\r\n  /**\r\n   * Get the validity extent for this projection.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getExtent() {\r\n    return this.extent_;\r\n  }\r\n\r\n  /**\r\n   * Get the units of this projection.\r\n   * @return {import(\"./Units.js\").Units} Units.\r\n   * @api\r\n   */\r\n  getUnits() {\r\n    return this.units_;\r\n  }\r\n\r\n  /**\r\n   * Get the amount of meters per unit of this projection.  If the projection is\r\n   * not configured with `metersPerUnit` or a units identifier, the return is\r\n   * `undefined`.\r\n   * @return {number|undefined} Meters.\r\n   * @api\r\n   */\r\n  getMetersPerUnit() {\r\n    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\r\n  }\r\n\r\n  /**\r\n   * Get the world extent for this projection.\r\n   * @return {import(\"../extent.js\").Extent} Extent.\r\n   * @api\r\n   */\r\n  getWorldExtent() {\r\n    return this.worldExtent_;\r\n  }\r\n\r\n  /**\r\n   * Get the axis orientation of this projection.\r\n   * Example values are:\r\n   * enu - the default easting, northing, elevation.\r\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\r\n   *     or south orientated transverse mercator.\r\n   * wnu - westing, northing, up - some planetary coordinate systems have\r\n   *     \"west positive\" coordinate systems\r\n   * @return {string} Axis orientation.\r\n   * @api\r\n   */\r\n  getAxisOrientation() {\r\n    return this.axisOrientation_;\r\n  }\r\n\r\n  /**\r\n   * Is this projection a global projection which spans the whole world?\r\n   * @return {boolean} Whether the projection is global.\r\n   * @api\r\n   */\r\n  isGlobal() {\r\n    return this.global_;\r\n  }\r\n\r\n  /**\r\n   * Set if the projection is a global projection which spans the whole world\r\n   * @param {boolean} global Whether the projection is global.\r\n   * @api\r\n   */\r\n  setGlobal(global) {\r\n    this.global_ = global;\r\n    this.canWrapX_ = !!(global && this.extent_);\r\n  }\r\n\r\n  /**\r\n   * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\r\n   */\r\n  getDefaultTileGrid() {\r\n    return this.defaultTileGrid_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\r\n   */\r\n  setDefaultTileGrid(tileGrid) {\r\n    this.defaultTileGrid_ = tileGrid;\r\n  }\r\n\r\n  /**\r\n   * Set the validity extent for this projection.\r\n   * @param {import(\"../extent.js\").Extent} extent Extent.\r\n   * @api\r\n   */\r\n  setExtent(extent) {\r\n    this.extent_ = extent;\r\n    this.canWrapX_ = !!(this.global_ && extent);\r\n  }\r\n\r\n  /**\r\n   * Set the world extent for this projection.\r\n   * @param {import(\"../extent.js\").Extent} worldExtent World extent\r\n   *     [minlon, minlat, maxlon, maxlat].\r\n   * @api\r\n   */\r\n  setWorldExtent(worldExtent) {\r\n    this.worldExtent_ = worldExtent;\r\n  }\r\n\r\n  /**\r\n   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\r\n   * for this projection.\r\n   * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\r\n   * @api\r\n   */\r\n  setGetPointResolution(func) {\r\n    this.getPointResolutionFunc_ = func;\r\n  }\r\n\r\n  /**\r\n   * Get the custom point resolution function for this projection (if set).\r\n   * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\r\n   * resolution function (if set).\r\n   */\r\n  getPointResolutionFunc() {\r\n    return this.getPointResolutionFunc_;\r\n  }\r\n}\r\n\r\nexport default Projection;\r\n", "/**\r\n * @module ol/proj/epsg3857\r\n */\r\nimport Projection from './Projection.js';\r\n\r\n/**\r\n * Radius of WGS84 sphere\r\n *\r\n * @const\r\n * @type {number}\r\n */\r\nexport const RADIUS = 6378137;\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const HALF_SIZE = Math.PI * RADIUS;\r\n\r\n/**\r\n * @const\r\n * @type {import(\"../extent.js\").Extent}\r\n */\r\nexport const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\r\n\r\n/**\r\n * @const\r\n * @type {import(\"../extent.js\").Extent}\r\n */\r\nexport const WORLD_EXTENT = [-180, -85, 180, 85];\r\n\r\n/**\r\n * Maximum safe value in y direction\r\n * @const\r\n * @type {number}\r\n */\r\nexport const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\r\n\r\n/**\r\n * @classdesc\r\n * Projection object for web/spherical Mercator (EPSG:3857).\r\n */\r\nclass EPSG3857Projection extends Projection {\r\n  /**\r\n   * @param {string} code Code.\r\n   */\r\n  constructor(code) {\r\n    super({\r\n      code: code,\r\n      units: 'm',\r\n      extent: EXTENT,\r\n      global: true,\r\n      worldExtent: WORLD_EXTENT,\r\n      getPointResolution: function (resolution, point) {\r\n        return resolution / Math.cosh(point[1] / RADIUS);\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Projections equal to EPSG:3857.\r\n *\r\n * @const\r\n * @type {Array<import(\"./Projection.js\").default>}\r\n */\r\nexport const PROJECTIONS = [\r\n  new EPSG3857Projection('EPSG:3857'),\r\n  new EPSG3857Projection('EPSG:102100'),\r\n  new EPSG3857Projection('EPSG:102113'),\r\n  new EPSG3857Projection('EPSG:900913'),\r\n  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),\r\n  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),\r\n];\r\n\r\n/**\r\n * Transformation from EPSG:4326 to EPSG:3857.\r\n *\r\n * @param {Array<number>} input Input array of coordinate values.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @param {number} [dimension] Dimension (default is `2`).\r\n * @return {Array<number>} Output array of coordinate values.\r\n */\r\nexport function fromEPSG4326(input, output, dimension) {\r\n  const length = input.length;\r\n  dimension = dimension > 1 ? dimension : 2;\r\n  if (output === undefined) {\r\n    if (dimension > 2) {\r\n      // preserve values beyond second dimension\r\n      output = input.slice();\r\n    } else {\r\n      output = new Array(length);\r\n    }\r\n  }\r\n  for (let i = 0; i < length; i += dimension) {\r\n    output[i] = (HALF_SIZE * input[i]) / 180;\r\n    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));\r\n    if (y > MAX_SAFE_Y) {\r\n      y = MAX_SAFE_Y;\r\n    } else if (y < -MAX_SAFE_Y) {\r\n      y = -MAX_SAFE_Y;\r\n    }\r\n    output[i + 1] = y;\r\n  }\r\n  return output;\r\n}\r\n\r\n/**\r\n * Transformation from EPSG:3857 to EPSG:4326.\r\n *\r\n * @param {Array<number>} input Input array of coordinate values.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @param {number} [dimension] Dimension (default is `2`).\r\n * @return {Array<number>} Output array of coordinate values.\r\n */\r\nexport function toEPSG4326(input, output, dimension) {\r\n  const length = input.length;\r\n  dimension = dimension > 1 ? dimension : 2;\r\n  if (output === undefined) {\r\n    if (dimension > 2) {\r\n      // preserve values beyond second dimension\r\n      output = input.slice();\r\n    } else {\r\n      output = new Array(length);\r\n    }\r\n  }\r\n  for (let i = 0; i < length; i += dimension) {\r\n    output[i] = (180 * input[i]) / HALF_SIZE;\r\n    output[i + 1] =\r\n      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;\r\n  }\r\n  return output;\r\n}\r\n", "/**\r\n * @module ol/proj/epsg4326\r\n */\r\nimport Projection from './Projection.js';\r\n\r\n/**\r\n * Semi-major radius of the WGS84 ellipsoid.\r\n *\r\n * @const\r\n * @type {number}\r\n */\r\nexport const RADIUS = 6378137;\r\n\r\n/**\r\n * Extent of the EPSG:4326 projection which is the whole world.\r\n *\r\n * @const\r\n * @type {import(\"../extent.js\").Extent}\r\n */\r\nexport const EXTENT = [-180, -90, 180, 90];\r\n\r\n/**\r\n * @const\r\n * @type {number}\r\n */\r\nexport const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;\r\n\r\n/**\r\n * @classdesc\r\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\r\n *\r\n * Note that OpenLayers does not strictly comply with the EPSG definition.\r\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\r\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\r\n */\r\nclass EPSG4326Projection extends Projection {\r\n  /**\r\n   * @param {string} code Code.\r\n   * @param {string} [axisOrientation] Axis orientation.\r\n   */\r\n  constructor(code, axisOrientation) {\r\n    super({\r\n      code: code,\r\n      units: 'degrees',\r\n      extent: EXTENT,\r\n      axisOrientation: axisOrientation,\r\n      global: true,\r\n      metersPerUnit: METERS_PER_UNIT,\r\n      worldExtent: EXTENT,\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Projections equal to EPSG:4326.\r\n *\r\n * @const\r\n * @type {Array<import(\"./Projection.js\").default>}\r\n */\r\nexport const PROJECTIONS = [\r\n  new EPSG4326Projection('CRS:84'),\r\n  new EPSG4326Projection('EPSG:4326', 'neu'),\r\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),\r\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),\r\n  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),\r\n  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\r\n  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),\r\n];\r\n", "/**\r\n * @module ol/proj/projections\r\n */\r\n\r\n/**\r\n * @type {Object<string, import(\"./Projection.js\").default>}\r\n */\r\nlet cache = {};\r\n\r\n/**\r\n * Clear the projections cache.\r\n */\r\nexport function clear() {\r\n  cache = {};\r\n}\r\n\r\n/**\r\n * Get a cached projection by code.\r\n * @param {string} code The code for the projection.\r\n * @return {import(\"./Projection.js\").default} The projection (if cached).\r\n */\r\nexport function get(code) {\r\n  return (\r\n    cache[code] ||\r\n    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, 'EPSG:$3')] ||\r\n    null\r\n  );\r\n}\r\n\r\n/**\r\n * Add a projection to the cache.\r\n * @param {string} code The projection code.\r\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\r\n */\r\nexport function add(code, projection) {\r\n  cache[code] = projection;\r\n}\r\n", "/**\r\n * @module ol/proj/transforms\r\n */\r\nimport {isEmpty} from '../obj.js';\r\n\r\n/**\r\n * @private\r\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\r\n */\r\nlet transforms = {};\r\n\r\n/**\r\n * Clear the transform cache.\r\n */\r\nexport function clear() {\r\n  transforms = {};\r\n}\r\n\r\n/**\r\n * Registers a conversion function to convert coordinates from the source\r\n * projection to the destination projection.\r\n *\r\n * @param {import(\"./Projection.js\").default} source Source.\r\n * @param {import(\"./Projection.js\").default} destination Destination.\r\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\r\n */\r\nexport function add(source, destination, transformFn) {\r\n  const sourceCode = source.getCode();\r\n  const destinationCode = destination.getCode();\r\n  if (!(sourceCode in transforms)) {\r\n    transforms[sourceCode] = {};\r\n  }\r\n  transforms[sourceCode][destinationCode] = transformFn;\r\n}\r\n\r\n/**\r\n * Unregisters the conversion function to convert coordinates from the source\r\n * projection to the destination projection.  This method is used to clean up\r\n * cached transforms during testing.\r\n *\r\n * @param {import(\"./Projection.js\").default} source Source projection.\r\n * @param {import(\"./Projection.js\").default} destination Destination projection.\r\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\r\n */\r\nexport function remove(source, destination) {\r\n  const sourceCode = source.getCode();\r\n  const destinationCode = destination.getCode();\r\n  const transform = transforms[sourceCode][destinationCode];\r\n  delete transforms[sourceCode][destinationCode];\r\n  if (isEmpty(transforms[sourceCode])) {\r\n    delete transforms[sourceCode];\r\n  }\r\n  return transform;\r\n}\r\n\r\n/**\r\n * Get a transform given a source code and a destination code.\r\n * @param {string} sourceCode The code for the source projection.\r\n * @param {string} destinationCode The code for the destination projection.\r\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\r\n */\r\nexport function get(sourceCode, destinationCode) {\r\n  let transform;\r\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\r\n    transform = transforms[sourceCode][destinationCode];\r\n  }\r\n  return transform;\r\n}\r\n", "/**\r\n * @module ol/extent/Relationship\r\n */\r\n\r\n/**\r\n * Relationship to an extent.\r\n * @enum {number}\r\n */\r\nexport default {\r\n  UNKNOWN: 0,\r\n  INTERSECTING: 1,\r\n  ABOVE: 2,\r\n  RIGHT: 4,\r\n  BELOW: 8,\r\n  LEFT: 16,\r\n};\r\n", "/**\r\n * @module ol/extent\r\n */\r\nimport Relationship from './extent/Relationship.js';\r\n\r\n/**\r\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\r\n * @typedef {Array<number>} Extent\r\n * @api\r\n */\r\n\r\n/**\r\n * Extent corner.\r\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\r\n */\r\n\r\n/**\r\n * Build an extent that includes all given coordinates.\r\n *\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @return {Extent} Bounding extent.\r\n * @api\r\n */\r\nexport function boundingExtent(coordinates) {\r\n  const extent = createEmpty();\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    extendCoordinate(extent, coordinates[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} xs Xs.\r\n * @param {Array<number>} ys Ys.\r\n * @param {Extent} [dest] Destination extent.\r\n * @private\r\n * @return {Extent} Extent.\r\n */\r\nfunction _boundingExtentXYs(xs, ys, dest) {\r\n  const minX = Math.min.apply(null, xs);\r\n  const minY = Math.min.apply(null, ys);\r\n  const maxX = Math.max.apply(null, xs);\r\n  const maxY = Math.max.apply(null, ys);\r\n  return createOrUpdate(minX, minY, maxX, maxY, dest);\r\n}\r\n\r\n/**\r\n * Return extent increased by the provided value.\r\n * @param {Extent} extent Extent.\r\n * @param {number} value The amount by which the extent should be buffered.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n * @api\r\n */\r\nexport function buffer(extent, value, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0] - value;\r\n    dest[1] = extent[1] - value;\r\n    dest[2] = extent[2] + value;\r\n    dest[3] = extent[3] + value;\r\n    return dest;\r\n  }\r\n  return [\r\n    extent[0] - value,\r\n    extent[1] - value,\r\n    extent[2] + value,\r\n    extent[3] + value,\r\n  ];\r\n}\r\n\r\n/**\r\n * Creates a clone of an extent.\r\n *\r\n * @param {Extent} extent Extent to clone.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} The clone.\r\n */\r\nexport function clone(extent, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0];\r\n    dest[1] = extent[1];\r\n    dest[2] = extent[2];\r\n    dest[3] = extent[3];\r\n    return dest;\r\n  }\r\n  return extent.slice();\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n * @return {number} Closest squared distance.\r\n */\r\nexport function closestSquaredDistanceXY(extent, x, y) {\r\n  let dx, dy;\r\n  if (x < extent[0]) {\r\n    dx = extent[0] - x;\r\n  } else if (extent[2] < x) {\r\n    dx = x - extent[2];\r\n  } else {\r\n    dx = 0;\r\n  }\r\n  if (y < extent[1]) {\r\n    dy = extent[1] - y;\r\n  } else if (extent[3] < y) {\r\n    dy = y - extent[3];\r\n  } else {\r\n    dy = 0;\r\n  }\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * Check if the passed coordinate is contained or on the edge of the extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @return {boolean} The coordinate is contained in the extent.\r\n * @api\r\n */\r\nexport function containsCoordinate(extent, coordinate) {\r\n  return containsXY(extent, coordinate[0], coordinate[1]);\r\n}\r\n\r\n/**\r\n * Check if one extent contains another.\r\n *\r\n * An extent is deemed contained if it lies completely within the other extent,\r\n * including if they share one or more edges.\r\n *\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {boolean} The second extent is contained by or on the edge of the\r\n *     first.\r\n * @api\r\n */\r\nexport function containsExtent(extent1, extent2) {\r\n  return (\r\n    extent1[0] <= extent2[0] &&\r\n    extent2[2] <= extent1[2] &&\r\n    extent1[1] <= extent2[1] &&\r\n    extent2[3] <= extent1[3]\r\n  );\r\n}\r\n\r\n/**\r\n * Check if the passed coordinate is contained or on the edge of the extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X coordinate.\r\n * @param {number} y Y coordinate.\r\n * @return {boolean} The x, y values are contained in the extent.\r\n * @api\r\n */\r\nexport function containsXY(extent, x, y) {\r\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\r\n}\r\n\r\n/**\r\n * Get the relationship between a coordinate and extent.\r\n * @param {Extent} extent The extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\r\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\r\n *     import(\"./extent/Relationship.js\").Relationship).\r\n */\r\nexport function coordinateRelationship(extent, coordinate) {\r\n  const minX = extent[0];\r\n  const minY = extent[1];\r\n  const maxX = extent[2];\r\n  const maxY = extent[3];\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  let relationship = Relationship.UNKNOWN;\r\n  if (x < minX) {\r\n    relationship = relationship | Relationship.LEFT;\r\n  } else if (x > maxX) {\r\n    relationship = relationship | Relationship.RIGHT;\r\n  }\r\n  if (y < minY) {\r\n    relationship = relationship | Relationship.BELOW;\r\n  } else if (y > maxY) {\r\n    relationship = relationship | Relationship.ABOVE;\r\n  }\r\n  if (relationship === Relationship.UNKNOWN) {\r\n    relationship = Relationship.INTERSECTING;\r\n  }\r\n  return relationship;\r\n}\r\n\r\n/**\r\n * Create an empty extent.\r\n * @return {Extent} Empty extent.\r\n * @api\r\n */\r\nexport function createEmpty() {\r\n  return [Infinity, Infinity, -Infinity, -Infinity];\r\n}\r\n\r\n/**\r\n * Create a new extent or update the provided extent.\r\n * @param {number} minX Minimum X.\r\n * @param {number} minY Minimum Y.\r\n * @param {number} maxX Maximum X.\r\n * @param {number} maxY Maximum Y.\r\n * @param {Extent} [dest] Destination extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdate(minX, minY, maxX, maxY, dest) {\r\n  if (dest) {\r\n    dest[0] = minX;\r\n    dest[1] = minY;\r\n    dest[2] = maxX;\r\n    dest[3] = maxY;\r\n    return dest;\r\n  }\r\n  return [minX, minY, maxX, maxY];\r\n}\r\n\r\n/**\r\n * Create a new empty extent or make the provided one empty.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateEmpty(dest) {\r\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromCoordinate(coordinate, dest) {\r\n  const x = coordinate[0];\r\n  const y = coordinate[1];\r\n  return createOrUpdate(x, y, x, y, dest);\r\n}\r\n\r\n/**\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromCoordinates(coordinates, dest) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendCoordinates(extent, coordinates);\r\n}\r\n\r\n/**\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromFlatCoordinates(\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n  dest,\r\n) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\r\n}\r\n\r\n/**\r\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function createOrUpdateFromRings(rings, dest) {\r\n  const extent = createOrUpdateEmpty(dest);\r\n  return extendRings(extent, rings);\r\n}\r\n\r\n/**\r\n * Determine if two extents are equivalent.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {boolean} The two extents are equivalent.\r\n * @api\r\n */\r\nexport function equals(extent1, extent2) {\r\n  return (\r\n    extent1[0] == extent2[0] &&\r\n    extent1[2] == extent2[2] &&\r\n    extent1[1] == extent2[1] &&\r\n    extent1[3] == extent2[3]\r\n  );\r\n}\r\n\r\n/**\r\n * Determine if two extents are approximately equivalent.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @param {number} tolerance Tolerance in extent coordinate units.\r\n * @return {boolean} The two extents differ by less than the tolerance.\r\n */\r\nexport function approximatelyEquals(extent1, extent2, tolerance) {\r\n  return (\r\n    Math.abs(extent1[0] - extent2[0]) < tolerance &&\r\n    Math.abs(extent1[2] - extent2[2]) < tolerance &&\r\n    Math.abs(extent1[1] - extent2[1]) < tolerance &&\r\n    Math.abs(extent1[3] - extent2[3]) < tolerance\r\n  );\r\n}\r\n\r\n/**\r\n * Modify an extent to include another extent.\r\n * @param {Extent} extent1 The extent to be modified.\r\n * @param {Extent} extent2 The extent that will be included in the first.\r\n * @return {Extent} A reference to the first (extended) extent.\r\n * @api\r\n */\r\nexport function extend(extent1, extent2) {\r\n  if (extent2[0] < extent1[0]) {\r\n    extent1[0] = extent2[0];\r\n  }\r\n  if (extent2[2] > extent1[2]) {\r\n    extent1[2] = extent2[2];\r\n  }\r\n  if (extent2[1] < extent1[1]) {\r\n    extent1[1] = extent2[1];\r\n  }\r\n  if (extent2[3] > extent1[3]) {\r\n    extent1[3] = extent2[3];\r\n  }\r\n  return extent1;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n */\r\nexport function extendCoordinate(extent, coordinate) {\r\n  if (coordinate[0] < extent[0]) {\r\n    extent[0] = coordinate[0];\r\n  }\r\n  if (coordinate[0] > extent[2]) {\r\n    extent[2] = coordinate[0];\r\n  }\r\n  if (coordinate[1] < extent[1]) {\r\n    extent[1] = coordinate[1];\r\n  }\r\n  if (coordinate[1] > extent[3]) {\r\n    extent[3] = coordinate[1];\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendCoordinates(extent, coordinates) {\r\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\r\n    extendCoordinate(extent, coordinates[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<number>} flatCoordinates Flat coordinates.\r\n * @param {number} offset Offset.\r\n * @param {number} end End.\r\n * @param {number} stride Stride.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendFlatCoordinates(\r\n  extent,\r\n  flatCoordinates,\r\n  offset,\r\n  end,\r\n  stride,\r\n) {\r\n  for (; offset < end; offset += stride) {\r\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\r\n * @return {Extent} Extent.\r\n */\r\nexport function extendRings(extent, rings) {\r\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\r\n    extendCoordinates(extent, rings[i]);\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} x X.\r\n * @param {number} y Y.\r\n */\r\nexport function extendXY(extent, x, y) {\r\n  extent[0] = Math.min(extent[0], x);\r\n  extent[1] = Math.min(extent[1], y);\r\n  extent[2] = Math.max(extent[2], x);\r\n  extent[3] = Math.max(extent[3], y);\r\n}\r\n\r\n/**\r\n * This function calls `callback` for each corner of the extent. If the\r\n * callback returns a truthy value the function returns that value\r\n * immediately. Otherwise the function returns `false`.\r\n * @param {Extent} extent Extent.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\r\n * @return {S|boolean} Value.\r\n * @template S\r\n */\r\nexport function forEachCorner(extent, callback) {\r\n  let val;\r\n  val = callback(getBottomLeft(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getBottomRight(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getTopRight(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  val = callback(getTopLeft(extent));\r\n  if (val) {\r\n    return val;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get the size of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Area.\r\n * @api\r\n */\r\nexport function getArea(extent) {\r\n  let area = 0;\r\n  if (!isEmpty(extent)) {\r\n    area = getWidth(extent) * getHeight(extent);\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * Get the bottom left coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\r\n * @api\r\n */\r\nexport function getBottomLeft(extent) {\r\n  return [extent[0], extent[1]];\r\n}\r\n\r\n/**\r\n * Get the bottom right coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\r\n * @api\r\n */\r\nexport function getBottomRight(extent) {\r\n  return [extent[2], extent[1]];\r\n}\r\n\r\n/**\r\n * Get the center coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Center.\r\n * @api\r\n */\r\nexport function getCenter(extent) {\r\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\r\n}\r\n\r\n/**\r\n * Get a corner coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @param {Corner} corner Corner.\r\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\r\n */\r\nexport function getCorner(extent, corner) {\r\n  let coordinate;\r\n  if (corner === 'bottom-left') {\r\n    coordinate = getBottomLeft(extent);\r\n  } else if (corner === 'bottom-right') {\r\n    coordinate = getBottomRight(extent);\r\n  } else if (corner === 'top-left') {\r\n    coordinate = getTopLeft(extent);\r\n  } else if (corner === 'top-right') {\r\n    coordinate = getTopRight(extent);\r\n  } else {\r\n    throw new Error('Invalid corner');\r\n  }\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {number} Enlarged area.\r\n */\r\nexport function getEnlargedArea(extent1, extent2) {\r\n  const minX = Math.min(extent1[0], extent2[0]);\r\n  const minY = Math.min(extent1[1], extent2[1]);\r\n  const maxX = Math.max(extent1[2], extent2[2]);\r\n  const maxY = Math.max(extent1[3], extent2[3]);\r\n  return (maxX - minX) * (maxY - minY);\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\r\n * @param {number} resolution Resolution.\r\n * @param {number} rotation Rotation.\r\n * @param {import(\"./size.js\").Size} size Size.\r\n * @param {Extent} [dest] Destination extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function getForViewAndSize(center, resolution, rotation, size, dest) {\r\n  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(\r\n    center,\r\n    resolution,\r\n    rotation,\r\n    size,\r\n  );\r\n  return createOrUpdate(\r\n    Math.min(x0, x1, x2, x3),\r\n    Math.min(y0, y1, y2, y3),\r\n    Math.max(x0, x1, x2, x3),\r\n    Math.max(y0, y1, y2, y3),\r\n    dest,\r\n  );\r\n}\r\n\r\n/**\r\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\r\n * @param {number} resolution Resolution.\r\n * @param {number} rotation Rotation.\r\n * @param {import(\"./size.js\").Size} size Size.\r\n * @return {Array<number>} Linear ring representing the viewport.\r\n */\r\nexport function getRotatedViewport(center, resolution, rotation, size) {\r\n  const dx = (resolution * size[0]) / 2;\r\n  const dy = (resolution * size[1]) / 2;\r\n  const cosRotation = Math.cos(rotation);\r\n  const sinRotation = Math.sin(rotation);\r\n  const xCos = dx * cosRotation;\r\n  const xSin = dx * sinRotation;\r\n  const yCos = dy * cosRotation;\r\n  const ySin = dy * sinRotation;\r\n  const x = center[0];\r\n  const y = center[1];\r\n  return [\r\n    x - xCos + ySin,\r\n    y - xSin - yCos,\r\n    x - xCos - ySin,\r\n    y - xSin + yCos,\r\n    x + xCos - ySin,\r\n    y + xSin + yCos,\r\n    x + xCos + ySin,\r\n    y + xSin - yCos,\r\n    x - xCos + ySin,\r\n    y - xSin - yCos,\r\n  ];\r\n}\r\n\r\n/**\r\n * Get the height of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Height.\r\n * @api\r\n */\r\nexport function getHeight(extent) {\r\n  return extent[3] - extent[1];\r\n}\r\n\r\n/**\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @return {number} Intersection area.\r\n */\r\nexport function getIntersectionArea(extent1, extent2) {\r\n  const intersection = getIntersection(extent1, extent2);\r\n  return getArea(intersection);\r\n}\r\n\r\n/**\r\n * Get the intersection of two extents.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent 2.\r\n * @param {Extent} [dest] Optional extent to populate with intersection.\r\n * @return {Extent} Intersecting extent.\r\n * @api\r\n */\r\nexport function getIntersection(extent1, extent2, dest) {\r\n  const intersection = dest ? dest : createEmpty();\r\n  if (intersects(extent1, extent2)) {\r\n    if (extent1[0] > extent2[0]) {\r\n      intersection[0] = extent1[0];\r\n    } else {\r\n      intersection[0] = extent2[0];\r\n    }\r\n    if (extent1[1] > extent2[1]) {\r\n      intersection[1] = extent1[1];\r\n    } else {\r\n      intersection[1] = extent2[1];\r\n    }\r\n    if (extent1[2] < extent2[2]) {\r\n      intersection[2] = extent1[2];\r\n    } else {\r\n      intersection[2] = extent2[2];\r\n    }\r\n    if (extent1[3] < extent2[3]) {\r\n      intersection[3] = extent1[3];\r\n    } else {\r\n      intersection[3] = extent2[3];\r\n    }\r\n  } else {\r\n    createOrUpdateEmpty(intersection);\r\n  }\r\n  return intersection;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @return {number} Margin.\r\n */\r\nexport function getMargin(extent) {\r\n  return getWidth(extent) + getHeight(extent);\r\n}\r\n\r\n/**\r\n * Get the size (width, height) of an extent.\r\n * @param {Extent} extent The extent.\r\n * @return {import(\"./size.js\").Size} The extent size.\r\n * @api\r\n */\r\nexport function getSize(extent) {\r\n  return [extent[2] - extent[0], extent[3] - extent[1]];\r\n}\r\n\r\n/**\r\n * Get the top left coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\r\n * @api\r\n */\r\nexport function getTopLeft(extent) {\r\n  return [extent[0], extent[3]];\r\n}\r\n\r\n/**\r\n * Get the top right coordinate of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\r\n * @api\r\n */\r\nexport function getTopRight(extent) {\r\n  return [extent[2], extent[3]];\r\n}\r\n\r\n/**\r\n * Get the width of an extent.\r\n * @param {Extent} extent Extent.\r\n * @return {number} Width.\r\n * @api\r\n */\r\nexport function getWidth(extent) {\r\n  return extent[2] - extent[0];\r\n}\r\n\r\n/**\r\n * Determine if one extent intersects another.\r\n * @param {Extent} extent1 Extent 1.\r\n * @param {Extent} extent2 Extent.\r\n * @return {boolean} The two extents intersect.\r\n * @api\r\n */\r\nexport function intersects(extent1, extent2) {\r\n  return (\r\n    extent1[0] <= extent2[2] &&\r\n    extent1[2] >= extent2[0] &&\r\n    extent1[1] <= extent2[3] &&\r\n    extent1[3] >= extent2[1]\r\n  );\r\n}\r\n\r\n/**\r\n * Determine if an extent is empty.\r\n * @param {Extent} extent Extent.\r\n * @return {boolean} Is empty.\r\n * @api\r\n */\r\nexport function isEmpty(extent) {\r\n  return extent[2] < extent[0] || extent[3] < extent[1];\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {Extent} [dest] Extent.\r\n * @return {Extent} Extent.\r\n */\r\nexport function returnOrUpdate(extent, dest) {\r\n  if (dest) {\r\n    dest[0] = extent[0];\r\n    dest[1] = extent[1];\r\n    dest[2] = extent[2];\r\n    dest[3] = extent[3];\r\n    return dest;\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * @param {Extent} extent Extent.\r\n * @param {number} value Value.\r\n */\r\nexport function scaleFromCenter(extent, value) {\r\n  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\r\n  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\r\n  extent[0] -= deltaX;\r\n  extent[2] += deltaX;\r\n  extent[1] -= deltaY;\r\n  extent[3] += deltaY;\r\n}\r\n\r\n/**\r\n * Determine if the segment between two coordinates intersects (crosses,\r\n * touches, or is contained by) the provided extent.\r\n * @param {Extent} extent The extent.\r\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\r\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\r\n * @return {boolean} The segment intersects the extent.\r\n */\r\nexport function intersectsSegment(extent, start, end) {\r\n  let intersects = false;\r\n  const startRel = coordinateRelationship(extent, start);\r\n  const endRel = coordinateRelationship(extent, end);\r\n  if (\r\n    startRel === Relationship.INTERSECTING ||\r\n    endRel === Relationship.INTERSECTING\r\n  ) {\r\n    intersects = true;\r\n  } else {\r\n    const minX = extent[0];\r\n    const minY = extent[1];\r\n    const maxX = extent[2];\r\n    const maxY = extent[3];\r\n    const startX = start[0];\r\n    const startY = start[1];\r\n    const endX = end[0];\r\n    const endY = end[1];\r\n    const slope = (endY - startY) / (endX - startX);\r\n    let x, y;\r\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\r\n      // potentially intersects top\r\n      x = endX - (endY - maxY) / slope;\r\n      intersects = x >= minX && x <= maxX;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.RIGHT) &&\r\n      !(startRel & Relationship.RIGHT)\r\n    ) {\r\n      // potentially intersects right\r\n      y = endY - (endX - maxX) * slope;\r\n      intersects = y >= minY && y <= maxY;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.BELOW) &&\r\n      !(startRel & Relationship.BELOW)\r\n    ) {\r\n      // potentially intersects bottom\r\n      x = endX - (endY - minY) / slope;\r\n      intersects = x >= minX && x <= maxX;\r\n    }\r\n    if (\r\n      !intersects &&\r\n      !!(endRel & Relationship.LEFT) &&\r\n      !(startRel & Relationship.LEFT)\r\n    ) {\r\n      // potentially intersects left\r\n      y = endY - (endX - minX) * slope;\r\n      intersects = y >= minY && y <= maxY;\r\n    }\r\n  }\r\n  return intersects;\r\n}\r\n\r\n/**\r\n * Apply a transform function to the extent.\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\r\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\r\n * @param {Extent} [dest] Destination extent.\r\n * @param {number} [stops] Number of stops per side used for the transform.\r\n * By default only the corners are used.\r\n * @return {Extent} Extent.\r\n * @api\r\n */\r\nexport function applyTransform(extent, transformFn, dest, stops) {\r\n  if (isEmpty(extent)) {\r\n    return createOrUpdateEmpty(dest);\r\n  }\r\n  let coordinates = [];\r\n  if (stops > 1) {\r\n    const width = extent[2] - extent[0];\r\n    const height = extent[3] - extent[1];\r\n    for (let i = 0; i < stops; ++i) {\r\n      coordinates.push(\r\n        extent[0] + (width * i) / stops,\r\n        extent[1],\r\n        extent[2],\r\n        extent[1] + (height * i) / stops,\r\n        extent[2] - (width * i) / stops,\r\n        extent[3],\r\n        extent[0],\r\n        extent[3] - (height * i) / stops,\r\n      );\r\n    }\r\n  } else {\r\n    coordinates = [\r\n      extent[0],\r\n      extent[1],\r\n      extent[2],\r\n      extent[1],\r\n      extent[2],\r\n      extent[3],\r\n      extent[0],\r\n      extent[3],\r\n    ];\r\n  }\r\n  transformFn(coordinates, coordinates, 2);\r\n  const xs = [];\r\n  const ys = [];\r\n  for (let i = 0, l = coordinates.length; i < l; i += 2) {\r\n    xs.push(coordinates[i]);\r\n    ys.push(coordinates[i + 1]);\r\n  }\r\n  return _boundingExtentXYs(xs, ys, dest);\r\n}\r\n\r\n/**\r\n * Modifies the provided extent in-place to be within the real world\r\n * extent.\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection\r\n * @return {Extent} The extent within the real world extent.\r\n */\r\nexport function wrapX(extent, projection) {\r\n  const projectionExtent = projection.getExtent();\r\n  const center = getCenter(extent);\r\n  if (\r\n    projection.canWrapX() &&\r\n    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])\r\n  ) {\r\n    const worldWidth = getWidth(projectionExtent);\r\n    const worldsAway = Math.floor(\r\n      (center[0] - projectionExtent[0]) / worldWidth,\r\n    );\r\n    const offset = worldsAway * worldWidth;\r\n    extent[0] -= offset;\r\n    extent[2] -= offset;\r\n  }\r\n  return extent;\r\n}\r\n\r\n/**\r\n * Fits the extent to the real world\r\n *\r\n * If the extent does not cross the anti meridian, this will return the extent in an array\r\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\r\n * real world\r\n *\r\n *\r\n * @param {Extent} extent Extent.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection\r\n * @param {boolean} [multiWorld] Return all worlds\r\n * @return {Array<Extent>} The extent within the real world extent.\r\n */\r\nexport function wrapAndSliceX(extent, projection, multiWorld) {\r\n  if (projection.canWrapX()) {\r\n    const projectionExtent = projection.getExtent();\r\n\r\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\r\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\r\n    }\r\n\r\n    wrapX(extent, projection);\r\n    const worldWidth = getWidth(projectionExtent);\r\n\r\n    if (getWidth(extent) > worldWidth && !multiWorld) {\r\n      // the extent wraps around on itself\r\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\r\n    }\r\n    if (extent[0] < projectionExtent[0]) {\r\n      // the extent crosses the anti meridian, so it needs to be sliced\r\n      return [\r\n        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],\r\n        [projectionExtent[0], extent[1], extent[2], extent[3]],\r\n      ];\r\n    }\r\n    if (extent[2] > projectionExtent[2]) {\r\n      // the extent crosses the anti meridian, so it needs to be sliced\r\n      return [\r\n        [extent[0], extent[1], projectionExtent[2], extent[3]],\r\n        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],\r\n      ];\r\n    }\r\n  }\r\n\r\n  return [extent];\r\n}\r\n", "/**\r\n * @module ol/string\r\n */\r\n\r\n/**\r\n * @param {number} number Number to be formatted\r\n * @param {number} width The desired width\r\n * @param {number} [precision] Precision of the output string (i.e. number of decimal places)\r\n * @return {string} Formatted string\r\n */\r\nexport function padNumber(number, width, precision) {\r\n  const numberString =\r\n    precision !== undefined ? number.toFixed(precision) : '' + number;\r\n  let decimal = numberString.indexOf('.');\r\n  decimal = decimal === -1 ? numberString.length : decimal;\r\n  return decimal > width\r\n    ? numberString\r\n    : new Array(1 + width - decimal).join('0') + numberString;\r\n}\r\n\r\n/**\r\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\r\n * @param {string|number} v1 First version\r\n * @param {string|number} v2 Second version\r\n * @return {number} Value\r\n */\r\nexport function compareVersions(v1, v2) {\r\n  const s1 = ('' + v1).split('.');\r\n  const s2 = ('' + v2).split('.');\r\n\r\n  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {\r\n    const n1 = parseInt(s1[i] || '0', 10);\r\n    const n2 = parseInt(s2[i] || '0', 10);\r\n\r\n    if (n1 > n2) {\r\n      return 1;\r\n    }\r\n    if (n2 > n1) {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n", "/**\r\n * @module ol/coordinate\r\n */\r\nimport {getWidth} from './extent.js';\r\nimport {modulo, toFixed} from './math.js';\r\nimport {padNumber} from './string.js';\r\n\r\n/**\r\n * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.\r\n * Example: `[16, 48]`.\r\n * @typedef {Array<number>} Coordinate\r\n * @api\r\n */\r\n\r\n/**\r\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\r\n * transforms it into a `{string}`.\r\n *\r\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\r\n * @api\r\n */\r\n\r\n/**\r\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\r\n * by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {add} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     add(coord, [-2, 4]);\r\n *     // coord is now [5.85, 51.983333]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {Coordinate} delta Delta.\r\n * @return {Coordinate} The input coordinate adjusted by\r\n * the given delta.\r\n * @api\r\n */\r\nexport function add(coordinate, delta) {\r\n  coordinate[0] += +delta[0];\r\n  coordinate[1] += +delta[1];\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * Calculates the point closest to the passed coordinate on the passed circle.\r\n *\r\n * @param {Coordinate} coordinate The coordinate.\r\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\r\n * @return {Coordinate} Closest point on the circumference.\r\n */\r\nexport function closestOnCircle(coordinate, circle) {\r\n  const r = circle.getRadius();\r\n  const center = circle.getCenter();\r\n  const x0 = center[0];\r\n  const y0 = center[1];\r\n  const x1 = coordinate[0];\r\n  const y1 = coordinate[1];\r\n\r\n  let dx = x1 - x0;\r\n  const dy = y1 - y0;\r\n  if (dx === 0 && dy === 0) {\r\n    dx = 1;\r\n  }\r\n  const d = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  const x = x0 + (r * dx) / d;\r\n  const y = y0 + (r * dy) / d;\r\n\r\n  return [x, y];\r\n}\r\n\r\n/**\r\n * Calculates the point closest to the passed coordinate on the passed segment.\r\n * This is the foot of the perpendicular of the coordinate to the segment when\r\n * the foot is on the segment, or the closest segment coordinate when the foot\r\n * is outside the segment.\r\n *\r\n * @param {Coordinate} coordinate The coordinate.\r\n * @param {Array<Coordinate>} segment The two coordinates\r\n * of the segment.\r\n * @return {Coordinate} The foot of the perpendicular of\r\n * the coordinate to the segment.\r\n */\r\nexport function closestOnSegment(coordinate, segment) {\r\n  const x0 = coordinate[0];\r\n  const y0 = coordinate[1];\r\n  const start = segment[0];\r\n  const end = segment[1];\r\n  const x1 = start[0];\r\n  const y1 = start[1];\r\n  const x2 = end[0];\r\n  const y2 = end[1];\r\n  const dx = x2 - x1;\r\n  const dy = y2 - y1;\r\n  const along =\r\n    dx === 0 && dy === 0\r\n      ? 0\r\n      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\r\n  let x, y;\r\n  if (along <= 0) {\r\n    x = x1;\r\n    y = y1;\r\n  } else if (along >= 1) {\r\n    x = x2;\r\n    y = y2;\r\n  } else {\r\n    x = x1 + along * dx;\r\n    y = y1 + along * dy;\r\n  }\r\n  return [x, y];\r\n}\r\n\r\n/**\r\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\r\n * used to format\r\n * a {Coordinate} to a string.\r\n *\r\n * Example without specifying the fractional digits:\r\n *\r\n *     import {createStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const stringifyFunc = createStringXY();\r\n *     const out = stringifyFunc(coord);\r\n *     // out is now '8, 48'\r\n *\r\n * Example with explicitly specifying 2 fractional digits:\r\n *\r\n *     import {createStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const stringifyFunc = createStringXY(2);\r\n *     const out = stringifyFunc(coord);\r\n *     // out is now '7.85, 47.98'\r\n *\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {CoordinateFormat} Coordinate format.\r\n * @api\r\n */\r\nexport function createStringXY(fractionDigits) {\r\n  return (\r\n    /**\r\n     * @param {Coordinate} coordinate Coordinate.\r\n     * @return {string} String XY.\r\n     */\r\n    function (coordinate) {\r\n      return toStringXY(coordinate, fractionDigits);\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * @param {string} hemispheres Hemispheres.\r\n * @param {number} degrees Degrees.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} String.\r\n */\r\nexport function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {\r\n  const normalizedDegrees = modulo(degrees + 180, 360) - 180;\r\n  const x = Math.abs(3600 * normalizedDegrees);\r\n  const decimals = fractionDigits || 0;\r\n\r\n  let deg = Math.floor(x / 3600);\r\n  let min = Math.floor((x - deg * 3600) / 60);\r\n  let sec = toFixed(x - deg * 3600 - min * 60, decimals);\r\n\r\n  if (sec >= 60) {\r\n    sec = 0;\r\n    min += 1;\r\n  }\r\n\r\n  if (min >= 60) {\r\n    min = 0;\r\n    deg += 1;\r\n  }\r\n\r\n  let hdms = deg + '\\u00b0';\r\n  if (min !== 0 || sec !== 0) {\r\n    hdms += ' ' + padNumber(min, 2) + '\\u2032';\r\n  }\r\n  if (sec !== 0) {\r\n    hdms += ' ' + padNumber(sec, 2, decimals) + '\\u2033';\r\n  }\r\n  if (normalizedDegrees !== 0) {\r\n    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);\r\n  }\r\n\r\n  return hdms;\r\n}\r\n\r\n/**\r\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\r\n * using the given string template. The strings `{x}` and `{y}` in the template\r\n * will be replaced with the first and second coordinate values respectively.\r\n *\r\n * Example without specifying the fractional digits:\r\n *\r\n *     import {format} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const template = 'Coordinate is ({x}|{y}).';\r\n *     const out = format(coord, template);\r\n *     // out is now 'Coordinate is (8|48).'\r\n *\r\n * Example explicitly specifying the fractional digits:\r\n *\r\n *     import {format} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const template = 'Coordinate is ({x}|{y}).';\r\n *     const out = format(coord, template, 2);\r\n *     // out is now 'Coordinate is (7.85|47.98).'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {string} template A template string with `{x}` and `{y}` placeholders\r\n *     that will be replaced by first and second coordinate values.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} Formatted coordinate.\r\n * @api\r\n */\r\nexport function format(coordinate, template, fractionDigits) {\r\n  if (coordinate) {\r\n    return template\r\n      .replace('{x}', coordinate[0].toFixed(fractionDigits))\r\n      .replace('{y}', coordinate[1].toFixed(fractionDigits));\r\n  }\r\n  return '';\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coordinate1 First coordinate.\r\n * @param {Coordinate} coordinate2 Second coordinate.\r\n * @return {boolean} The two coordinates are equal.\r\n */\r\nexport function equals(coordinate1, coordinate2) {\r\n  let equals = true;\r\n  for (let i = coordinate1.length - 1; i >= 0; --i) {\r\n    if (coordinate1[i] != coordinate2[i]) {\r\n      equals = false;\r\n      break;\r\n    }\r\n  }\r\n  return equals;\r\n}\r\n\r\n/**\r\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\r\n * returned by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {rotate} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const rotateRadians = Math.PI / 2; // 90 degrees\r\n *     rotate(coord, rotateRadians);\r\n *     // coord is now [-47.983333, 7.85]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} angle Angle in radian.\r\n * @return {Coordinate} Coordinate.\r\n * @api\r\n */\r\nexport function rotate(coordinate, angle) {\r\n  const cosAngle = Math.cos(angle);\r\n  const sinAngle = Math.sin(angle);\r\n  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\r\n  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\r\n  coordinate[0] = x;\r\n  coordinate[1] = y;\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\r\n * by the function.\r\n *\r\n * Example:\r\n *\r\n *     import {scale as scaleCoordinate} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const scale = 1.2;\r\n *     scaleCoordinate(coord, scale);\r\n *     // coord is now [9.42, 57.5799996]\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} scale Scale factor.\r\n * @return {Coordinate} Coordinate.\r\n */\r\nexport function scale(coordinate, scale) {\r\n  coordinate[0] *= scale;\r\n  coordinate[1] *= scale;\r\n  return coordinate;\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coord1 First coordinate.\r\n * @param {Coordinate} coord2 Second coordinate.\r\n * @return {number} Squared distance between coord1 and coord2.\r\n */\r\nexport function squaredDistance(coord1, coord2) {\r\n  const dx = coord1[0] - coord2[0];\r\n  const dy = coord1[1] - coord2[1];\r\n  return dx * dx + dy * dy;\r\n}\r\n\r\n/**\r\n * @param {Coordinate} coord1 First coordinate.\r\n * @param {Coordinate} coord2 Second coordinate.\r\n * @return {number} Distance between coord1 and coord2.\r\n */\r\nexport function distance(coord1, coord2) {\r\n  return Math.sqrt(squaredDistance(coord1, coord2));\r\n}\r\n\r\n/**\r\n * Calculate the squared distance from a coordinate to a line segment.\r\n *\r\n * @param {Coordinate} coordinate Coordinate of the point.\r\n * @param {Array<Coordinate>} segment Line segment (2\r\n * coordinates).\r\n * @return {number} Squared distance from the point to the line segment.\r\n */\r\nexport function squaredDistanceToSegment(coordinate, segment) {\r\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\r\n}\r\n\r\n/**\r\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\r\n * seconds.\r\n *\r\n * Example without specifying fractional digits:\r\n *\r\n *     import {toStringHDMS} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringHDMS(coord);\r\n *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'\r\n *\r\n * Example explicitly specifying 1 fractional digit:\r\n *\r\n *     import {toStringHDMS} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringHDMS(coord, 1);\r\n *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} Hemisphere, degrees, minutes and seconds.\r\n * @api\r\n */\r\nexport function toStringHDMS(coordinate, fractionDigits) {\r\n  if (coordinate) {\r\n    return (\r\n      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +\r\n      ' ' +\r\n      degreesToStringHDMS('EW', coordinate[0], fractionDigits)\r\n    );\r\n  }\r\n  return '';\r\n}\r\n\r\n/**\r\n * Format a coordinate as a comma delimited string.\r\n *\r\n * Example without specifying fractional digits:\r\n *\r\n *     import {toStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringXY(coord);\r\n *     // out is now '8, 48'\r\n *\r\n * Example explicitly specifying 1 fractional digit:\r\n *\r\n *     import {toStringXY} from 'ol/coordinate.js';\r\n *\r\n *     const coord = [7.85, 47.983333];\r\n *     const out = toStringXY(coord, 1);\r\n *     // out is now '7.8, 48.0'\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {number} [fractionDigits] The number of digits to include\r\n *    after the decimal point. Default is `0`.\r\n * @return {string} XY.\r\n * @api\r\n */\r\nexport function toStringXY(coordinate, fractionDigits) {\r\n  return format(coordinate, '{x}, {y}', fractionDigits);\r\n}\r\n\r\n/**\r\n * Modifies the provided coordinate in-place to be within the real world\r\n * extent. The lower projection extent boundary is inclusive, the upper one\r\n * exclusive.\r\n *\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @return {Coordinate} The coordinate within the real world extent.\r\n */\r\nexport function wrapX(coordinate, projection) {\r\n  if (projection.canWrapX()) {\r\n    const worldWidth = getWidth(projection.getExtent());\r\n    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);\r\n    if (worldsAway) {\r\n      coordinate[0] -= worldsAway * worldWidth;\r\n    }\r\n  }\r\n  return coordinate;\r\n}\r\n/**\r\n * @param {Coordinate} coordinate Coordinate.\r\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\r\n * @param {number} [sourceExtentWidth] Width of the source extent.\r\n * @return {number} Offset in world widths.\r\n */\r\nexport function getWorldsAway(coordinate, projection, sourceExtentWidth) {\r\n  const projectionExtent = projection.getExtent();\r\n  let worldsAway = 0;\r\n  if (\r\n    projection.canWrapX() &&\r\n    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])\r\n  ) {\r\n    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);\r\n    worldsAway = Math.floor(\r\n      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth,\r\n    );\r\n  }\r\n  return worldsAway;\r\n}\r\n", "/**\r\n * @module ol/sphere\r\n */\r\nimport {toDegrees, toRadians} from './math.js';\r\n\r\n/**\r\n * Object literal with options for the {@link getLength} or {@link getArea}\r\n * functions.\r\n * @typedef {Object} SphereMetricOptions\r\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\r\n * Projection of the  geometry.  By default, the geometry is assumed to be in\r\n * Web Mercator.\r\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\r\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\r\n * for the WGS84 ellipsoid is used.\r\n */\r\n\r\n/**\r\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\r\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\r\n * @type {number}\r\n */\r\nexport const DEFAULT_RADIUS = 6371008.8;\r\n\r\n/**\r\n * Get the great circle distance (in meters) between two geographic coordinates.\r\n * @param {Array} c1 Starting coordinate.\r\n * @param {Array} c2 Ending coordinate.\r\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\r\n *     mean radius using the WGS84 ellipsoid.\r\n * @return {number} The great circle distance between the points (in meters).\r\n * @api\r\n */\r\nexport function getDistance(c1, c2, radius) {\r\n  radius = radius || DEFAULT_RADIUS;\r\n  const lat1 = toRadians(c1[1]);\r\n  const lat2 = toRadians(c2[1]);\r\n  const deltaLatBy2 = (lat2 - lat1) / 2;\r\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\r\n  const a =\r\n    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\r\n    Math.sin(deltaLonBy2) *\r\n      Math.sin(deltaLonBy2) *\r\n      Math.cos(lat1) *\r\n      Math.cos(lat2);\r\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n}\r\n\r\n/**\r\n * Get the cumulative great circle length of linestring coordinates (geographic).\r\n * @param {Array} coordinates Linestring coordinates.\r\n * @param {number} radius The sphere radius to use.\r\n * @return {number} The length (in meters).\r\n */\r\nfunction getLengthInternal(coordinates, radius) {\r\n  let length = 0;\r\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\r\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\r\n  }\r\n  return length;\r\n}\r\n\r\n/**\r\n * Get the spherical length of a geometry.  This length is the sum of the\r\n * great circle distances between coordinates.  For polygons, the length is\r\n * the sum of all rings.  For points, the length is zero.  For multi-part\r\n * geometries, the length is the sum of the length of each part.\r\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\r\n * @param {SphereMetricOptions} [options] Options for the\r\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\r\n * You can change this by providing a `projection` option.\r\n * @return {number} The spherical length (in meters).\r\n * @api\r\n */\r\nexport function getLength(geometry, options) {\r\n  options = options || {};\r\n  const radius = options.radius || DEFAULT_RADIUS;\r\n  const projection = options.projection || 'EPSG:3857';\r\n  const type = geometry.getType();\r\n  if (type !== 'GeometryCollection') {\r\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\r\n  }\r\n  let length = 0;\r\n  let coordinates, coords, i, ii, j, jj;\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'MultiPoint': {\r\n      break;\r\n    }\r\n    case 'LineString':\r\n    case 'LinearRing': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      length = getLengthInternal(coordinates, radius);\r\n      break;\r\n    }\r\n    case 'MultiLineString':\r\n    case 'Polygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        length += getLengthInternal(coordinates[i], radius);\r\n      }\r\n      break;\r\n    }\r\n    case 'MultiPolygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        coords = coordinates[i];\r\n        for (j = 0, jj = coords.length; j < jj; ++j) {\r\n          length += getLengthInternal(coords[j], radius);\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case 'GeometryCollection': {\r\n      const geometries =\r\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries();\r\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\r\n        length += getLength(geometries[i], options);\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error('Unsupported geometry type: ' + type);\r\n    }\r\n  }\r\n  return length;\r\n}\r\n\r\n/**\r\n * Returns the spherical area for a list of coordinates.\r\n *\r\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\r\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\r\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\r\n * Laboratory, Pasadena, CA, June 2007\r\n *\r\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\r\n * ring. If the ring is oriented clockwise, the area will be positive,\r\n * otherwise it will be negative.\r\n * @param {number} radius The sphere radius.\r\n * @return {number} Area (in square meters).\r\n */\r\nfunction getAreaInternal(coordinates, radius) {\r\n  let area = 0;\r\n  const len = coordinates.length;\r\n  let x1 = coordinates[len - 1][0];\r\n  let y1 = coordinates[len - 1][1];\r\n  for (let i = 0; i < len; i++) {\r\n    const x2 = coordinates[i][0];\r\n    const y2 = coordinates[i][1];\r\n    area +=\r\n      toRadians(x2 - x1) *\r\n      (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\r\n    x1 = x2;\r\n    y1 = y2;\r\n  }\r\n  return (area * radius * radius) / 2.0;\r\n}\r\n\r\n/**\r\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\r\n * that polygon edges are segments of great circles on a sphere.\r\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\r\n * @param {SphereMetricOptions} [options] Options for the area\r\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\r\n *     You can change this by providing a `projection` option.\r\n * @return {number} The spherical area (in square meters).\r\n * @api\r\n */\r\nexport function getArea(geometry, options) {\r\n  options = options || {};\r\n  const radius = options.radius || DEFAULT_RADIUS;\r\n  const projection = options.projection || 'EPSG:3857';\r\n  const type = geometry.getType();\r\n  if (type !== 'GeometryCollection') {\r\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\r\n  }\r\n  let area = 0;\r\n  let coordinates, coords, i, ii, j, jj;\r\n  switch (type) {\r\n    case 'Point':\r\n    case 'MultiPoint':\r\n    case 'LineString':\r\n    case 'MultiLineString':\r\n    case 'LinearRing': {\r\n      break;\r\n    }\r\n    case 'Polygon': {\r\n      coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\r\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\r\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\r\n      }\r\n      break;\r\n    }\r\n    case 'MultiPolygon': {\r\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\r\n        geometry\r\n      ).getCoordinates();\r\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\r\n        coords = coordinates[i];\r\n        area += Math.abs(getAreaInternal(coords[0], radius));\r\n        for (j = 1, jj = coords.length; j < jj; ++j) {\r\n          area -= Math.abs(getAreaInternal(coords[j], radius));\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    case 'GeometryCollection': {\r\n      const geometries =\r\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\r\n          geometry\r\n        ).getGeometries();\r\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\r\n        area += getArea(geometries[i], options);\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      throw new Error('Unsupported geometry type: ' + type);\r\n    }\r\n  }\r\n  return area;\r\n}\r\n\r\n/**\r\n * Returns the coordinate at the given distance and bearing from `c1`.\r\n *\r\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\r\n * @param {number} distance The great-circle distance between the origin\r\n *     point and the target point.\r\n * @param {number} bearing The bearing (in radians).\r\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\r\n *     mean radius using the WGS84 ellipsoid.\r\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\r\n */\r\nexport function offset(c1, distance, bearing, radius) {\r\n  radius = radius || DEFAULT_RADIUS;\r\n  const lat1 = toRadians(c1[1]);\r\n  const lon1 = toRadians(c1[0]);\r\n  const dByR = distance / radius;\r\n  const lat = Math.asin(\r\n    Math.sin(lat1) * Math.cos(dByR) +\r\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing),\r\n  );\r\n  const lon =\r\n    lon1 +\r\n    Math.atan2(\r\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\r\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat),\r\n    );\r\n  return [toDegrees(lon), toDegrees(lat)];\r\n}\r\n", "/**\r\n * @module ol/console\r\n */\r\n\r\n/**\r\n * @typedef {'info'|'warn'|'error'|'none'} Level\r\n */\r\n\r\n/**\r\n * @type {Object<Level, number>}\r\n */\r\nconst levels = {\r\n  info: 1,\r\n  warn: 2,\r\n  error: 3,\r\n  none: 4,\r\n};\r\n\r\n/**\r\n * @type {number}\r\n */\r\nlet level = levels.info;\r\n\r\n/**\r\n * Set the logging level.  By default, the level is set to 'info' and all\r\n * messages will be logged.  Set to 'warn' to only display warnings and errors.\r\n * Set to 'error' to only display errors.  Set to 'none' to silence all messages.\r\n *\r\n * @param {Level} l The new level.\r\n */\r\nexport function setLevel(l) {\r\n  level = levels[l];\r\n}\r\n\r\n/**\r\n * @param  {...any} args Arguments to log\r\n */\r\nexport function log(...args) {\r\n  if (level > levels.info) {\r\n    return;\r\n  }\r\n  console.log(...args); // eslint-disable-line no-console\r\n}\r\n\r\n/**\r\n * @param  {...any} args Arguments to log\r\n */\r\nexport function warn(...args) {\r\n  if (level > levels.warn) {\r\n    return;\r\n  }\r\n  console.warn(...args); // eslint-disable-line no-console\r\n}\r\n\r\n/**\r\n * @param  {...any} args Arguments to log\r\n */\r\nexport function error(...args) {\r\n  if (level > levels.error) {\r\n    return;\r\n  }\r\n  console.error(...args); // eslint-disable-line no-console\r\n}\r\n", "/**\r\n * @module ol/proj\r\n */\r\n\r\n/**\r\n * The ol/proj module stores:\r\n * * a list of {@link module:ol/proj/Projection~Projection}\r\n * objects, one for each projection supported by the application\r\n * * a list of transform functions needed to convert coordinates in one projection\r\n * into another.\r\n *\r\n * The static functions are the methods used to maintain these.\r\n * Each transform function can handle not only simple coordinate pairs, but also\r\n * large arrays of coordinates such as vector geometries.\r\n *\r\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\r\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\r\n * for example by Bing Maps or OpenStreetMap), together with the relevant\r\n * transform functions.\r\n *\r\n * Additional transforms may be added by using the http://proj4js.org/\r\n * library (version 2.2 or later). You can use the full build supplied by\r\n * Proj4js, or create a custom build to support those projections you need; see\r\n * the Proj4js website for how to do this. You also need the Proj4js definitions\r\n * for the required projections. These definitions can be obtained from\r\n * https://epsg.io/, and are a JS function, so can be loaded in a script\r\n * tag (as in the examples) or pasted into your application.\r\n *\r\n * After all required projection definitions are added to proj4's registry (by\r\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\r\n * package. Existing transforms are not changed by this function. See\r\n * examples/wms-image-custom-proj for an example of this.\r\n *\r\n * Additional projection definitions can be registered with `proj4.defs()` any\r\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\r\n * know in advance what projections are needed, you can initially load minimal\r\n * support and then load whichever are requested.\r\n *\r\n * Note that Proj4js does not support projection extents. If you want to add\r\n * one for creating default tile grids, you can add it after the Projection\r\n * object has been created with `setExtent`, for example,\r\n * `get('EPSG:1234').setExtent(extent)`.\r\n *\r\n * In addition to Proj4js support, any transform functions can be added with\r\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\r\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\r\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\r\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\r\n * examples/wms-custom-proj for an example of this.\r\n *\r\n * Note that if no transforms are needed and you only need to define the\r\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\r\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\r\n * this.\r\n */\r\nimport Projection from './proj/Projection.js';\r\nimport {\r\n  PROJECTIONS as EPSG3857_PROJECTIONS,\r\n  fromEPSG4326,\r\n  toEPSG4326,\r\n} from './proj/epsg3857.js';\r\nimport {PROJECTIONS as EPSG4326_PROJECTIONS} from './proj/epsg4326.js';\r\nimport {METERS_PER_UNIT} from './proj/Units.js';\r\nimport {\r\n  add as addProj,\r\n  clear as clearProj,\r\n  get as getProj,\r\n} from './proj/projections.js';\r\nimport {\r\n  add as addTransformFunc,\r\n  clear as clearTransformFuncs,\r\n  get as getTransformFunc,\r\n} from './proj/transforms.js';\r\nimport {applyTransform, getWidth} from './extent.js';\r\nimport {clamp, modulo} from './math.js';\r\nimport {equals, getWorldsAway} from './coordinate.js';\r\nimport {getDistance} from './sphere.js';\r\nimport {warn} from './console.js';\r\n\r\n/**\r\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\r\n * string or undefined.\r\n * @typedef {Projection|string|undefined} ProjectionLike\r\n * @api\r\n */\r\n\r\n/**\r\n * A transform function accepts an array of input coordinate values, an optional\r\n * output array, and an optional dimension (default should be 2).  The function\r\n * transforms the input coordinate values, populates the output array, and\r\n * returns the output array.\r\n *\r\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\r\n * @api\r\n */\r\n\r\nexport {METERS_PER_UNIT};\r\n\r\nexport {Projection};\r\n\r\nlet showCoordinateWarning = true;\r\n\r\n/**\r\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\r\n */\r\nexport function disableCoordinateWarning(disable) {\r\n  const hide = disable === undefined ? true : disable;\r\n  showCoordinateWarning = !hide;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} input Input coordinate array.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @return {Array<number>} Output coordinate array (new array, same coordinate\r\n *     values).\r\n */\r\nexport function cloneTransform(input, output) {\r\n  if (output !== undefined) {\r\n    for (let i = 0, ii = input.length; i < ii; ++i) {\r\n      output[i] = input[i];\r\n    }\r\n    output = output;\r\n  } else {\r\n    output = input.slice();\r\n  }\r\n  return output;\r\n}\r\n\r\n/**\r\n * @param {Array<number>} input Input coordinate array.\r\n * @param {Array<number>} [output] Output array of coordinate values.\r\n * @return {Array<number>} Input coordinate array (same array as input).\r\n */\r\nexport function identityTransform(input, output) {\r\n  if (output !== undefined && input !== output) {\r\n    for (let i = 0, ii = input.length; i < ii; ++i) {\r\n      output[i] = input[i];\r\n    }\r\n    input = output;\r\n  }\r\n  return input;\r\n}\r\n\r\n/**\r\n * Add a Projection object to the list of supported projections that can be\r\n * looked up by their code.\r\n *\r\n * @param {Projection} projection Projection instance.\r\n * @api\r\n */\r\nexport function addProjection(projection) {\r\n  addProj(projection.getCode(), projection);\r\n  addTransformFunc(projection, projection, cloneTransform);\r\n}\r\n\r\n/**\r\n * @param {Array<Projection>} projections Projections.\r\n */\r\nexport function addProjections(projections) {\r\n  projections.forEach(addProjection);\r\n}\r\n\r\n/**\r\n * Fetches a Projection object for the code specified.\r\n *\r\n * @param {ProjectionLike} projectionLike Either a code string which is\r\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\r\n *     existing projection object, or undefined.\r\n * @return {Projection|null} Projection object, or null if not in list.\r\n * @api\r\n */\r\nexport function get(projectionLike) {\r\n  return typeof projectionLike === 'string'\r\n    ? getProj(/** @type {string} */ (projectionLike))\r\n    : /** @type {Projection} */ (projectionLike) || null;\r\n}\r\n\r\n/**\r\n * Get the resolution of the point in degrees or distance units.\r\n * For projections with degrees as the unit this will simply return the\r\n * provided resolution. For other projections the point resolution is\r\n * by default estimated by transforming the `point` pixel to EPSG:4326,\r\n * measuring its width and height on the normal sphere,\r\n * and taking the average of the width and height.\r\n * A custom function can be provided for a specific projection, either\r\n * by setting the `getPointResolution` option in the\r\n * {@link module:ol/proj/Projection~Projection} constructor or by using\r\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\r\n * projection object.\r\n * @param {ProjectionLike} projection The projection.\r\n * @param {number} resolution Nominal resolution in projection units.\r\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\r\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\r\n * Default is the projection's units.\r\n * @return {number} Point resolution.\r\n * @api\r\n */\r\nexport function getPointResolution(projection, resolution, point, units) {\r\n  projection = get(projection);\r\n  let pointResolution;\r\n  const getter = projection.getPointResolutionFunc();\r\n  if (getter) {\r\n    pointResolution = getter(resolution, point);\r\n    if (units && units !== projection.getUnits()) {\r\n      const metersPerUnit = projection.getMetersPerUnit();\r\n      if (metersPerUnit) {\r\n        pointResolution =\r\n          (pointResolution * metersPerUnit) / METERS_PER_UNIT[units];\r\n      }\r\n    }\r\n  } else {\r\n    const projUnits = projection.getUnits();\r\n    if ((projUnits == 'degrees' && !units) || units == 'degrees') {\r\n      pointResolution = resolution;\r\n    } else {\r\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\r\n      // measuring its width and height on the normal sphere, and taking the\r\n      // average of the width and height.\r\n      const toEPSG4326 = getTransformFromProjections(\r\n        projection,\r\n        get('EPSG:4326'),\r\n      );\r\n      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {\r\n        // no transform is available\r\n        pointResolution = resolution * projection.getMetersPerUnit();\r\n      } else {\r\n        let vertices = [\r\n          point[0] - resolution / 2,\r\n          point[1],\r\n          point[0] + resolution / 2,\r\n          point[1],\r\n          point[0],\r\n          point[1] - resolution / 2,\r\n          point[0],\r\n          point[1] + resolution / 2,\r\n        ];\r\n        vertices = toEPSG4326(vertices, vertices, 2);\r\n        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\r\n        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\r\n        pointResolution = (width + height) / 2;\r\n      }\r\n      const metersPerUnit = units\r\n        ? METERS_PER_UNIT[units]\r\n        : projection.getMetersPerUnit();\r\n      if (metersPerUnit !== undefined) {\r\n        pointResolution /= metersPerUnit;\r\n      }\r\n    }\r\n  }\r\n  return pointResolution;\r\n}\r\n\r\n/**\r\n * Registers transformation functions that don't alter coordinates. Those allow\r\n * to transform between projections with equal meaning.\r\n *\r\n * @param {Array<Projection>} projections Projections.\r\n * @api\r\n */\r\nexport function addEquivalentProjections(projections) {\r\n  addProjections(projections);\r\n  projections.forEach(function (source) {\r\n    projections.forEach(function (destination) {\r\n      if (source !== destination) {\r\n        addTransformFunc(source, destination, cloneTransform);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Registers transformation functions to convert coordinates in any projection\r\n * in projection1 to any projection in projection2.\r\n *\r\n * @param {Array<Projection>} projections1 Projections with equal\r\n *     meaning.\r\n * @param {Array<Projection>} projections2 Projections with equal\r\n *     meaning.\r\n * @param {TransformFunction} forwardTransform Transformation from any\r\n *   projection in projection1 to any projection in projection2.\r\n * @param {TransformFunction} inverseTransform Transform from any projection\r\n *   in projection2 to any projection in projection1..\r\n */\r\nexport function addEquivalentTransforms(\r\n  projections1,\r\n  projections2,\r\n  forwardTransform,\r\n  inverseTransform,\r\n) {\r\n  projections1.forEach(function (projection1) {\r\n    projections2.forEach(function (projection2) {\r\n      addTransformFunc(projection1, projection2, forwardTransform);\r\n      addTransformFunc(projection2, projection1, inverseTransform);\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Clear all cached projections and transforms.\r\n */\r\nexport function clearAllProjections() {\r\n  clearProj();\r\n  clearTransformFuncs();\r\n}\r\n\r\n/**\r\n * @param {Projection|string|undefined} projection Projection.\r\n * @param {string} defaultCode Default code.\r\n * @return {Projection} Projection.\r\n */\r\nexport function createProjection(projection, defaultCode) {\r\n  if (!projection) {\r\n    return get(defaultCode);\r\n  }\r\n  if (typeof projection === 'string') {\r\n    return get(projection);\r\n  }\r\n  return /** @type {Projection} */ (projection);\r\n}\r\n\r\n/**\r\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\r\n * function.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\r\n *     transform.\r\n * @return {TransformFunction} Transform function.\r\n */\r\nexport function createTransformFromCoordinateTransform(coordTransform) {\r\n  return (\r\n    /**\r\n     * @param {Array<number>} input Input.\r\n     * @param {Array<number>} [output] Output.\r\n     * @param {number} [dimension] Dimension.\r\n     * @return {Array<number>} Output.\r\n     */\r\n    function (input, output, dimension) {\r\n      const length = input.length;\r\n      dimension = dimension !== undefined ? dimension : 2;\r\n      output = output !== undefined ? output : new Array(length);\r\n      for (let i = 0; i < length; i += dimension) {\r\n        const point = coordTransform(input.slice(i, i + dimension));\r\n        const pointLength = point.length;\r\n        for (let j = 0, jj = dimension; j < jj; ++j) {\r\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\r\n        }\r\n      }\r\n      return output;\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Registers coordinate transform functions to convert coordinates between the\r\n * source projection and the destination projection.\r\n * The forward and inverse functions convert coordinate pairs; this function\r\n * converts these into the functions used internally which also handle\r\n * extents and coordinate arrays.\r\n *\r\n * @param {ProjectionLike} source Source projection.\r\n * @param {ProjectionLike} destination Destination projection.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\r\n *     function (that is, from the source projection to the destination\r\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\r\n *     the transformed {@link module:ol/coordinate~Coordinate}.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\r\n *     function (that is, from the destination projection to the source\r\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\r\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\r\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\r\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\r\n *     source.\r\n * @api\r\n */\r\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\r\n  const sourceProj = get(source);\r\n  const destProj = get(destination);\r\n  addTransformFunc(\r\n    sourceProj,\r\n    destProj,\r\n    createTransformFromCoordinateTransform(forward),\r\n  );\r\n  addTransformFunc(\r\n    destProj,\r\n    sourceProj,\r\n    createTransformFromCoordinateTransform(inverse),\r\n  );\r\n}\r\n\r\n/**\r\n * Transforms a coordinate from longitude/latitude to a different projection.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\r\n *     an array with longitude as 1st and latitude as 2nd element.\r\n * @param {ProjectionLike} [projection] Target projection. The\r\n *     default is Web Mercator, i.e. 'EPSG:3857'.\r\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\r\n * @api\r\n */\r\nexport function fromLonLat(coordinate, projection) {\r\n  disableCoordinateWarning();\r\n  return transform(\r\n    coordinate,\r\n    'EPSG:4326',\r\n    projection !== undefined ? projection : 'EPSG:3857',\r\n  );\r\n}\r\n\r\n/**\r\n * Transforms a coordinate to longitude/latitude.\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\r\n * @param {ProjectionLike} [projection] Projection of the coordinate.\r\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\r\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\r\n *     with longitude as 1st and latitude as 2nd element.\r\n * @api\r\n */\r\nexport function toLonLat(coordinate, projection) {\r\n  const lonLat = transform(\r\n    coordinate,\r\n    projection !== undefined ? projection : 'EPSG:3857',\r\n    'EPSG:4326',\r\n  );\r\n  const lon = lonLat[0];\r\n  if (lon < -180 || lon > 180) {\r\n    lonLat[0] = modulo(lon + 180, 360) - 180;\r\n  }\r\n  return lonLat;\r\n}\r\n\r\n/**\r\n * Checks if two projections are the same, that is every coordinate in one\r\n * projection does represent the same geographic point as the same coordinate in\r\n * the other projection.\r\n *\r\n * @param {Projection} projection1 Projection 1.\r\n * @param {Projection} projection2 Projection 2.\r\n * @return {boolean} Equivalent.\r\n * @api\r\n */\r\nexport function equivalent(projection1, projection2) {\r\n  if (projection1 === projection2) {\r\n    return true;\r\n  }\r\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\r\n  if (projection1.getCode() === projection2.getCode()) {\r\n    return equalUnits;\r\n  }\r\n  const transformFunc = getTransformFromProjections(projection1, projection2);\r\n  return transformFunc === cloneTransform && equalUnits;\r\n}\r\n\r\n/**\r\n * Searches in the list of transform functions for the function for converting\r\n * coordinates from the source projection to the destination projection.\r\n *\r\n * @param {Projection} sourceProjection Source Projection object.\r\n * @param {Projection} destinationProjection Destination Projection\r\n *     object.\r\n * @return {TransformFunction} Transform function.\r\n */\r\nexport function getTransformFromProjections(\r\n  sourceProjection,\r\n  destinationProjection,\r\n) {\r\n  const sourceCode = sourceProjection.getCode();\r\n  const destinationCode = destinationProjection.getCode();\r\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\r\n  if (!transformFunc) {\r\n    transformFunc = identityTransform;\r\n  }\r\n  return transformFunc;\r\n}\r\n\r\n/**\r\n * Given the projection-like objects, searches for a transformation\r\n * function to convert a coordinates array from the source projection to the\r\n * destination projection.\r\n *\r\n * @param {ProjectionLike} source Source.\r\n * @param {ProjectionLike} destination Destination.\r\n * @return {TransformFunction} Transform function.\r\n * @api\r\n */\r\nexport function getTransform(source, destination) {\r\n  const sourceProjection = get(source);\r\n  const destinationProjection = get(destination);\r\n  return getTransformFromProjections(sourceProjection, destinationProjection);\r\n}\r\n\r\n/**\r\n * Transforms a coordinate from source projection to destination projection.\r\n * This returns a new coordinate (and does not modify the original).\r\n *\r\n * See {@link module:ol/proj.transformExtent} for extent transformation.\r\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\r\n * subclasses for geometry transforms.\r\n *\r\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {ProjectionLike} source Source projection-like.\r\n * @param {ProjectionLike} destination Destination projection-like.\r\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\r\n * @api\r\n */\r\nexport function transform(coordinate, source, destination) {\r\n  const transformFunc = getTransform(source, destination);\r\n  return transformFunc(coordinate, undefined, coordinate.length);\r\n}\r\n\r\n/**\r\n * Transforms an extent from source projection to destination projection.  This\r\n * returns a new extent (and does not modify the original).\r\n *\r\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\r\n * @param {ProjectionLike} source Source projection-like.\r\n * @param {ProjectionLike} destination Destination projection-like.\r\n * @param {number} [stops] Number of stops per side used for the transform.\r\n * By default only the corners are used.\r\n * @return {import(\"./extent.js\").Extent} The transformed extent.\r\n * @api\r\n */\r\nexport function transformExtent(extent, source, destination, stops) {\r\n  const transformFunc = getTransform(source, destination);\r\n  return applyTransform(extent, transformFunc, undefined, stops);\r\n}\r\n\r\n/**\r\n * Transforms the given point to the destination projection.\r\n *\r\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\r\n * @param {Projection} sourceProjection Source projection.\r\n * @param {Projection} destinationProjection Destination projection.\r\n * @return {import(\"./coordinate.js\").Coordinate} Point.\r\n */\r\nexport function transformWithProjections(\r\n  point,\r\n  sourceProjection,\r\n  destinationProjection,\r\n) {\r\n  const transformFunc = getTransformFromProjections(\r\n    sourceProjection,\r\n    destinationProjection,\r\n  );\r\n  return transformFunc(point);\r\n}\r\n\r\n/**\r\n * @type {Projection|null}\r\n */\r\nlet userProjection = null;\r\n\r\n/**\r\n * Set the projection for coordinates supplied from and returned by API methods.\r\n * This includes all API methods except for those interacting with tile grids,\r\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\r\n * @param {ProjectionLike} projection The user projection.\r\n * @api\r\n */\r\nexport function setUserProjection(projection) {\r\n  userProjection = get(projection);\r\n}\r\n\r\n/**\r\n * Clear the user projection if set.\r\n * @api\r\n */\r\nexport function clearUserProjection() {\r\n  userProjection = null;\r\n}\r\n\r\n/**\r\n * Get the projection for coordinates supplied from and returned by API methods.\r\n * @return {Projection|null} The user projection (or null if not set).\r\n * @api\r\n */\r\nexport function getUserProjection() {\r\n  return userProjection;\r\n}\r\n\r\n/**\r\n * Use geographic coordinates (WGS-84 datum) in API methods.\r\n * This includes all API methods except for those interacting with tile grids,\r\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\r\n * @api\r\n */\r\nexport function useGeographic() {\r\n  setUserProjection('EPSG:4326');\r\n}\r\n\r\n/**\r\n * Return a coordinate transformed into the user projection.  If no user projection\r\n * is set, the original coordinate is returned.\r\n * @param {Array<number>} coordinate Input coordinate.\r\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\r\n * @return {Array<number>} The input coordinate in the user projection.\r\n */\r\nexport function toUserCoordinate(coordinate, sourceProjection) {\r\n  if (!userProjection) {\r\n    return coordinate;\r\n  }\r\n  return transform(coordinate, sourceProjection, userProjection);\r\n}\r\n\r\n/**\r\n * Return a coordinate transformed from the user projection.  If no user projection\r\n * is set, the original coordinate is returned.\r\n * @param {Array<number>} coordinate Input coordinate.\r\n * @param {ProjectionLike} destProjection The destination projection.\r\n * @return {Array<number>} The input coordinate transformed.\r\n */\r\nexport function fromUserCoordinate(coordinate, destProjection) {\r\n  if (!userProjection) {\r\n    if (\r\n      showCoordinateWarning &&\r\n      !equals(coordinate, [0, 0]) &&\r\n      coordinate[0] >= -180 &&\r\n      coordinate[0] <= 180 &&\r\n      coordinate[1] >= -90 &&\r\n      coordinate[1] <= 90\r\n    ) {\r\n      showCoordinateWarning = false;\r\n      warn(\r\n        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.',\r\n      );\r\n    }\r\n    return coordinate;\r\n  }\r\n  return transform(coordinate, userProjection, destProjection);\r\n}\r\n\r\n/**\r\n * Return an extent transformed into the user projection.  If no user projection\r\n * is set, the original extent is returned.\r\n * @param {import(\"./extent.js\").Extent} extent Input extent.\r\n * @param {ProjectionLike} sourceProjection The input extent projection.\r\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\r\n */\r\nexport function toUserExtent(extent, sourceProjection) {\r\n  if (!userProjection) {\r\n    return extent;\r\n  }\r\n  return transformExtent(extent, sourceProjection, userProjection);\r\n}\r\n\r\n/**\r\n * Return an extent transformed from the user projection.  If no user projection\r\n * is set, the original extent is returned.\r\n * @param {import(\"./extent.js\").Extent} extent Input extent.\r\n * @param {ProjectionLike} destProjection The destination projection.\r\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\r\n */\r\nexport function fromUserExtent(extent, destProjection) {\r\n  if (!userProjection) {\r\n    return extent;\r\n  }\r\n  return transformExtent(extent, userProjection, destProjection);\r\n}\r\n\r\n/**\r\n * Return the resolution in user projection units per pixel. If no user projection\r\n * is set, or source or user projection are missing units, the original resolution\r\n * is returned.\r\n * @param {number} resolution Resolution in input projection units per pixel.\r\n * @param {ProjectionLike} sourceProjection The input projection.\r\n * @return {number} Resolution in user projection units per pixel.\r\n */\r\nexport function toUserResolution(resolution, sourceProjection) {\r\n  if (!userProjection) {\r\n    return resolution;\r\n  }\r\n  const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();\r\n  const userMetersPerUnit = userProjection.getMetersPerUnit();\r\n  return sourceMetersPerUnit && userMetersPerUnit\r\n    ? (resolution * sourceMetersPerUnit) / userMetersPerUnit\r\n    : resolution;\r\n}\r\n\r\n/**\r\n * Return the resolution in user projection units per pixel. If no user projection\r\n * is set, or source or user projection are missing units, the original resolution\r\n * is returned.\r\n * @param {number} resolution Resolution in user projection units per pixel.\r\n * @param {ProjectionLike} destProjection The destination projection.\r\n * @return {number} Resolution in destination projection units per pixel.\r\n */\r\nexport function fromUserResolution(resolution, destProjection) {\r\n  if (!userProjection) {\r\n    return resolution;\r\n  }\r\n  const destMetersPerUnit = get(destProjection).getMetersPerUnit();\r\n  const userMetersPerUnit = userProjection.getMetersPerUnit();\r\n  return destMetersPerUnit && userMetersPerUnit\r\n    ? (resolution * userMetersPerUnit) / destMetersPerUnit\r\n    : resolution;\r\n}\r\n\r\n/**\r\n * Creates a safe coordinate transform function from a coordinate transform function.\r\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\r\n * and that coordinates exceeding the source projection validity extent's range will be\r\n * clamped to the validity range.\r\n * @param {Projection} sourceProj Source projection.\r\n * @param {Projection} destProj Destination projection.\r\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destination).\r\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destination).\r\n */\r\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\r\n  return function (coord) {\r\n    let transformed, worldsAway;\r\n    if (sourceProj.canWrapX()) {\r\n      const sourceExtent = sourceProj.getExtent();\r\n      const sourceExtentWidth = getWidth(sourceExtent);\r\n      coord = coord.slice(0);\r\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\r\n      if (worldsAway) {\r\n        // Move x to the real world\r\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\r\n      }\r\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\r\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\r\n      transformed = transform(coord);\r\n    } else {\r\n      transformed = transform(coord);\r\n    }\r\n    if (worldsAway && destProj.canWrapX()) {\r\n      // Move transformed coordinate back to the offset world\r\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\r\n    }\r\n    return transformed;\r\n  };\r\n}\r\n\r\n/**\r\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\r\n * by when this module is executed and should only need to be called again after\r\n * `clearAllProjections()` is called (e.g. in tests).\r\n */\r\nexport function addCommon() {\r\n  // Add transformations that don't alter coordinates to convert within set of\r\n  // projections with equal meaning.\r\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\r\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\r\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\r\n  // coordinates and back.\r\n  addEquivalentTransforms(\r\n    EPSG4326_PROJECTIONS,\r\n    EPSG3857_PROJECTIONS,\r\n    fromEPSG4326,\r\n    toEPSG4326,\r\n  );\r\n}\r\n\r\naddCommon();\r\n"],
  "mappings": "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",
  "names": ["RADIUS", "EXTENT", "METERS_PER_UNIT", "PROJECTIONS", "clear", "add", "get", "transform", "offset", "offset", "isEmpty", "isEmpty", "intersects", "offset", "add", "equals", "scale", "wrapX", "add", "get", "toEPSG4326", "clear", "equals", "transform", "PROJECTIONS"]
}
